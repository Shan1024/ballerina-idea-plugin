{

    parserClass="org.ballerina.parser.BallerinaParser"
    classHeader='CopyrightHeader.txt'

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Ballerina"
    psiImplClassSuffix="Impl"
    psiPackage="org.ballerina.psi"
    psiImplPackage="org.ballerina.psi.impl"

    elementTypeHolderClass="org.ballerina.psi.BallerinaTypes"
    elementTypeClass="org.ballerina.psi.BallerinaElementType"
    tokenTypeClass="org.ballerina.psi.BallerinaTokenType"

    tokens=[
        // Todo -  remove keywords after uncommenting all parser rules
        PACKAGE     = 'package'
        IMPORT      = 'import'
        AS          = 'as'
        PUBLIC      = 'public'
        PRIVATE      = 'private'
        NATIVE      = 'native'
        SERVICE     = 'service'
        RESOURCE    = 'resource'
        FUNCTION    = 'function'
        CONNECTOR   = 'connector'
        ACTION      = 'action'
        STRUCT      = 'struct'
        ANNOTATION  = 'annotation'
        ENUM        = 'enum'
//        PARAMETER   = 'parameter'
        CONST       = 'const'
        TRANSFORMER = 'transformer'
        WORKER      = 'worker'
        ENDPOINT    = 'endpoint'
        XMLNS       = 'xmlns'
        RETURNS     = 'returns'
//        VERSION     = 'version'

        TYPE_INT        = 'int'
        TYPE_FLOAT      = 'float'
        TYPE_BOOL       = 'boolean'
        TYPE_STRING     = 'string'
        TYPE_BLOB       = 'blob'
        TYPE_MAP        = 'map'
        TYPE_JSON       = 'json'
        TYPE_XML        = 'xml'
        TYPE_TABLE      = 'table'
        TYPE_ANY        = 'any'
        TYPE_TYPE       = 'type'

        VAR         = 'var'
        CREATE      = 'create'
        ATTACH      = 'attach'
        IF          = 'if'
        ELSE        = 'else'
        FOREACH     = 'foreach'
        WHILE       = 'while'
        NEXT        = 'next'
        BREAK       = 'break'
        FORK        = 'fork'
        JOIN        = 'join'
        SOME        = 'some'
        ALL         = 'all'
        TIMEOUT     = 'timeout'
        TRY         = 'try'
        CATCH       = 'catch'
        FINALLY     = 'finally'
        THROW       = 'throw'
        RETURN      = 'return'
        TRANSACTION = 'transaction'
        ABORT       = 'abort'
        FAILED      = 'failed'
        RETRIES     = 'retries'
        LENGTHOF    = 'lengthof'
        TYPEOF      = 'typeof'
        WITH        = 'with'
        BIND        = 'bind'
        IN          = 'in'
        LOCK        = 'lock'

        // Separators

        SEMICOLON           = ';'
        COLON               = ':'
        DOT                 = '.'
        COMMA               = ','
        LEFT_BRACE          = '{'
        RIGHT_BRACE         = '}'
        LEFT_PARENTHESIS    = '('
        RIGHT_PARENTHESIS   = ')'
        LEFT_BRACKET        = '['
        RIGHT_BRACKET       = ']'
        QUESTION_MARK       = '?'

        // Arithmetic operators

        ASSIGN  = '='
        ADD     = '+'
        SUB     = '-'
        MUL     = '*'
        DIV     = '/'
        POW     = '^'
        MOD     = '%'

        // Relational operators

        NOT         = '!'
        EQUAL       = '=='
        NOT_EQUAL   = '!='
        GT          = '>'
        LT          = '<'
        GT_EQUAL    = '>='
        LT_EQUAL    = '<='
        AND         = '&&'
        OR          = '||'

        // Additional symbols

        RARROW      = '->'
        LARROW      = '<-'
        AT          = '@'
        BACKTICK    = '`'
        RANGE       = '..'

        WHITE_SPACE = 'regexp:\s+'
        LINE_COMMENT = 'regexp://[^\r\n]*'
        identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
//        quotedStringLiteral = "regexp:\"((~[\"\\]|\\[btnfr\"'\\])+)?\""
        quotedStringLiteral = "regexp:\"(.*)\""
    ]
}

CompilationUnit ::= PackageDeclaration? (ImportDeclaration | NamespaceDeclaration)* (AnnotationAttachment* Definition)*

PackageDeclaration ::= package PackageName PackageVersion? SEMICOLON {pin=1}

PackageName ::= identifier (DOT identifier)* {pin=1}

PackageVersion ::= version identifier {pin=1};

ImportDeclaration ::= import PackageName PackageVersion? Alias? SEMICOLON {pin=1}

Alias ::= as identifier {pin=1}

Definition ::= ServiceDefinition | FunctionDefinition | connectorDefinition | structDefinition | enumDefinition |
constantDefinition | AnnotationDefinition | GlobalVariableDefinition | TransformerDefinition
{recoverWhile=TopLevelDefinitionRecover}

private TopLevelDefinitionRecover ::= !(service | function | connector | struct | enum | const | annotation | transformer)

ServiceDefinition ::= service (LT identifier GT) identifier ServiceBody {pin=1}
ServiceBody ::=   LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ResourceDefinition* RIGHT_BRACE

ResourceDefinition ::= AnnotationAttachment* RESOURCE identifier LEFT_PARENTHESIS ParameterList RIGHT_PARENTHESIS CallableUnitBody {pin=2}

CallableUnitBody ::= LEFT_BRACE EndpointDeclaration* Statement* RIGHT_BRACE | LEFT_BRACE EndpointDeclaration* WorkerDeclaration+ RIGHT_BRACE

FunctionDefinition ::= NativeFunctionDefinition | NonNativeFunctionDefinition
NativeFunctionDefinition ::= (PUBLIC)? NATIVE FUNCTION (LT Parameter GT)? CallableUnitSignature SEMICOLON {pin=3}
NonNativeFunctionDefinition ::= (PUBLIC)? FUNCTION (LT Parameter GT)? CallableUnitSignature CallableUnitBody {pin=2}

LambdaFunction ::= FUNCTION LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? CallableUnitBody

CallableUnitSignature ::= identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? {pin=1}

connectorDefinition ::= (public)? connector identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ConnectorBody {pin=2}

ConnectorBody ::= LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ActionDefinition* RIGHT_BRACE

ActionDefinition ::= NativeActionDefinition | NonNativeActionDefinition
NativeActionDefinition ::= AnnotationAttachment* native action  CallableUnitSignature SEMICOLON {pin=3}
NonNativeActionDefinition ::= AnnotationAttachment* action CallableUnitSignature CallableUnitBody {pin=2}

structDefinition ::= (public)? struct identifier StructBody {pin=2}

StructBody ::= LEFT_BRACE FieldDefinition* PrivateStructBody? RIGHT_BRACE

PrivateStructBody ::= PRIVATE COLON FieldDefinition*

AnnotationDefinition ::= (public)? annotation identifier (attach AttachmentPoint (COMMA AttachmentPoint)*)? AnnotationBody {pin=2}

enumDefinition ::= (public)? enum identifier LEFT_BRACE Enumerator (COMMA Enumerator)* RIGHT_BRACE

Enumerator ::= identifier

GlobalVariableDefinition ::= (public)? TypeName identifier (ASSIGN Expression )? SEMICOLON {pin=2}

TransformerDefinition ::= (public)? transformer LT ParameterList GT (identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS)? CallableUnitBody {pin=2}

// Todo - Enable parameter
AttachmentPoint ::= service (LT identifier? GT)? | resource | connector | action | function | struct | enum | const /*| parameter*/ | annotation | transformer

AnnotationBody ::= LEFT_BRACE FieldDefinition* RIGHT_BRACE

constantDefinition ::= (public)? const ValueTypeName identifier ASSIGN Expression SEMICOLON

WorkerDeclaration ::= WorkerDefinition LEFT_BRACE Statement* RIGHT_BRACE

WorkerDefinition ::= worker identifier

// Todo - Remove left recursion
TypeName ::= TYPE_ANY |TYPE_TYPE | ValueTypeName | ReferenceTypeName | /*TypeName*/ (LEFT_BRACKET RIGHT_BRACKET)+

BuiltInTypeName ::= TYPE_ANY | TYPE_TYPE | ValueTypeName | BuiltInReferenceTypeName | TypeName (LEFT_BRACKET RIGHT_BRACKET)+

ReferenceTypeName ::= BuiltInReferenceTypeName | UserDefineTypeName | AnonStructTypeName

UserDefineTypeName ::= NameReference

AnonStructTypeName ::= STRUCT StructBody

ValueTypeName ::=   TYPE_BOOL | TYPE_INT | TYPE_FLOAT | TYPE_STRING |TYPE_BLOB

BuiltInReferenceTypeName
    ::=   TYPE_MAP (LT TypeName GT)?
    |   TYPE_XML (LT (LEFT_BRACE XmlNamespaceName RIGHT_BRACE)? XmlLocalName GT)?
    |   TYPE_JSON (LT NameReference GT)?
    |   TYPE_TABLE (LT NameReference GT)?
    |   FunctionTypeName

FunctionTypeName ::= FUNCTION LEFT_PARENTHESIS (ParameterList | TypeList)? RIGHT_PARENTHESIS ReturnParameters?

XmlNamespaceName ::= quotedStringLiteral

XmlLocalName ::= identifier

AnnotationAttachment ::= AT NameReference LEFT_BRACE annotationAttributeList? RIGHT_BRACE {pin=1}

annotationAttributeList ::= AnnotationAttribute (COMMA AnnotationAttribute)*

AnnotationAttribute ::= identifier COLON AnnotationAttributeValue

AnnotationAttributeValue ::= SimpleLiteral | NameReference | AnnotationAttachment | AnnotationAttributeArray

AnnotationAttributeArray ::= LEFT_BRACKET (AnnotationAttributeValue (COMMA AnnotationAttributeValue)*)? RIGHT_BRACKET


// //============================================================================================================
//// STATEMENTS / BLOCKS

Statement
    ::= VariableDefinitionStatement
    |   AssignmentStatement
    |   BindStatement
    |   IfElseStatement
    |   ForeachStatement
    |   WhileStatement
    |   NextStatement
    |   BreakStatement
//    |   ForkJoinStatement
    |   TryCatchStatement
    |   ThrowStatement
    |   ReturnStatement
    |   WorkerInteractionStatement
    |   ExpressionStmt
    |   TransactionStatement
    |   AbortStatement
    |   LockStatement
    |   NamespaceDeclarationStatement



VariableDefinitionStatement ::= TypeName identifier (ASSIGN Expression)? SEMICOLON {pin(".*")=1}

RecordLiteral ::= LEFT_BRACE (RecordKeyValue (COMMA RecordKeyValue)*)? RIGHT_BRACE

RecordKeyValue ::= RecordKey COLON Expression

RecordKey ::= identifier | SimpleLiteral

ArrayLiteral ::= LEFT_BRACKET ExpressionList? RIGHT_BRACKET

ConnectorInit ::= create UserDefineTypeName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=1}

EndpointDeclaration ::= EndpointDefinition LEFT_BRACE ((VariableReference | ConnectorInit) SEMICOLON)? RIGHT_BRACE {pin=1}

EndpointDefinition ::= endpoint (LT NameReference GT) identifier {pin=1}

AssignmentStatement ::= (var)? VariableReferenceList ASSIGN Expression SEMICOLON {pin=2}

BindStatement ::= bind Expression WITH identifier SEMICOLON {pin=1}

VariableReferenceList ::= VariableReference (COMMA VariableReference)*

IfElseStatement ::= IfClause ElseIfClause* ElseClause?

IfClause ::= if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

ElseIfClause ::= else if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Statement* RIGHT_BRACE {pin=2}

ElseClause ::= else LEFT_BRACE Statement*RIGHT_BRACE {pin=1}

ForeachStatement ::= foreach LEFT_PARENTHESIS? VariableReferenceList in (Expression | IntRangeExpression) RIGHT_PARENTHESIS? LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

IntRangeExpression ::= Expression RANGE Expression | (LEFT_BRACKET|LEFT_PARENTHESIS) Expression RANGE Expression (RIGHT_BRACKET|RIGHT_PARENTHESIS)

WhileStatement ::= while LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

NextStatement ::= next SEMICOLON {pin=1}

BreakStatement ::= break SEMICOLON {pin=1}

//// typeName is only message
//forkJoinStatement
//    : FORK LEFT_BRACE workerDeclaration* RIGHT_BRACE joinClause? timeoutClause?
//    ;
//
//// below typeName is only 'message[]'
//joinClause
//    :   JOIN (LEFT_PARENTHESIS joinConditions RIGHT_PARENTHESIS)? LEFT_PARENTHESIS typeName identifier RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//joinConditions
//    : SOME IntegerLiteral (identifier (COMMA identifier)*)?     # anyJoinCondition
//    | ALL (identifier (COMMA identifier)*)?                     # allJoinCondition
//    ;
//
//// below typeName is only 'message[]'
//timeoutClause
//    :   TIMEOUT LEFT_PARENTHESIS expression RIGHT_PARENTHESIS LEFT_PARENTHESIS typeName identifier RIGHT_PARENTHESIS  LEFT_BRACE statement* RIGHT_BRACE
//    ;

TryCatchStatement ::= try LEFT_BRACE Statement* RIGHT_BRACE CatchClauses

CatchClauses ::= CatchClause+ FinallyClause? | FinallyClause

CatchClause ::= catch LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Statement* RIGHT_BRACE

FinallyClause ::= FINALLY LEFT_BRACE Statement* RIGHT_BRACE

ThrowStatement ::= throw Expression SEMICOLON

ReturnStatement ::= RETURN ExpressionList? SEMICOLON

WorkerInteractionStatement ::= TriggerWorker | WorkerReply

// below left identifier is of type TYPE_MESSAGE and the right identifier is of type WORKER
TriggerWorker ::= ExpressionList RARROW identifier SEMICOLON | ExpressionList RARROW fork SEMICOLON

// below left identifier is of type WORKER and the right identifier is of type message
WorkerReply ::= ExpressionList LARROW identifier SEMICOLON

// Todo - remove left recursion
VariableReference ::= FunctionInvocation | NameReference
//    |   VariableReference index
//    |   variableReference field
//    |   variableReference xmlAttrib
//    |   variableReference invocation

Field ::= DOT identifier

Index ::= LEFT_BRACKET Expression RIGHT_BRACKET

XmlAttrib ::= AT (LEFT_BRACKET Expression RIGHT_BRACKET)?

FunctionInvocation ::= NameReference LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=2}

Invocation ::= DOT AnyIdentifierName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS

ExpressionList ::= Expression (COMMA Expression)*

ExpressionStmt ::= VariableReference SEMICOLON

TransactionStatement ::= TransactionClause FailedClause?

TransactionClause ::= transaction (WITH TransactionPropertyInitStatementList)? LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

TransactionPropertyInitStatement ::= RetriesStatement

TransactionPropertyInitStatementList ::= TransactionPropertyInitStatement (COMMA TransactionPropertyInitStatement)*

LockStatement ::= lock LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

FailedClause ::= failed LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

AbortStatement ::= abort SEMICOLON {pin=1}

RetriesStatement ::= retries LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS {pin=1}

NamespaceDeclarationStatement ::= NamespaceDeclaration

NamespaceDeclaration ::= xmlns quotedStringLiteral (as identifier)? SEMICOLON {pin=1}

// Todo - Remove left recursion
Expression
    ::=  SimpleLiteral
    |   ArrayLiteral
    |   RecordLiteral
//    |   XmlLiteral
//    |   StringTemplateLiteral
    |   ValueTypeName DOT identifier
    |   BuiltInReferenceTypeName DOT identifier
    |   VariableReference
    |   LambdaFunction
    |   ConnectorInit
    |   LEFT_PARENTHESIS TypeName RIGHT_PARENTHESIS Expression
    |   LT TypeName (COMMA FunctionInvocation)? GT Expression
    |   typeof BuiltInTypeName
    |   (ADD | SUB | NOT | lengthof | typeof) Expression
    |   LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS
//    |   expression POW expression
//    |   expression (DIV | MUL | MOD) expression                             # binaryDivMulModExpression
//    |   expression (ADD | SUB) expression                                   # binaryAddSubExpression
//    |   expression (LT_EQUAL | GT_EQUAL | GT | LT) expression               # binaryCompareExpression
//    |   expression (EQUAL | NOT_EQUAL) expression                           # binaryEqualExpression
//    |   expression AND expression                                           # binaryAndExpression
//    |   expression OR expression                                            # binaryOrExpression
//    |   expression QUESTION_MARK expression COLON expression                # ternaryExpression


////reusable productions

NameReference ::= (identifier COLON)? identifier

ReturnParameters ::= RETURNS? LEFT_PARENTHESIS (ParameterList | TypeList) RIGHT_PARENTHESIS {pin=3}

private TypeList ::= TypeName (COMMA TypeName)* {pin=1}

ParameterList ::= Parameter (COMMA Parameter)* {pin=1}

Parameter ::= AnnotationAttachment* TypeName identifier

FieldDefinition ::= TypeName identifier (ASSIGN SimpleLiteral)? SEMICOLON

SimpleLiteral ::=
//    (ADD|SUB)? IntegerLiteral
//    | (ADD|SUB)? FloatingPointLiteral
//    |
    quotedStringLiteral
//    |   BooleanLiteral
//    |   NullLiteral

//// XML parsing
//
//xmlLiteral
//    :   XMLLiteralStart xmlItem XMLLiteralEnd
//    ;
//
//xmlItem
//    :   element
//    |   procIns
//    |   comment
//    |   text
//    |   CDATA
//    ;
//
//content
//    :   text? ((element | CDATA | procIns | comment) text?)*
//    ;
//
//comment
//    :   XML_COMMENT_START (XMLCommentTemplateText expression ExpressionEnd)* XMLCommentText
//    ;
//
//element
//    :   startTag content closeTag
//    |   emptyTag
//    ;
//
//startTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_CLOSE
//    ;
//
//closeTag
//    :   XML_TAG_OPEN_SLASH xmlQualifiedName XML_TAG_CLOSE
//    ;
//
//emptyTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_SLASH_CLOSE
//    ;
//
//procIns
//    :   XML_TAG_SPECIAL_OPEN (XMLPITemplateText expression ExpressionEnd)* XMLPIText
//    ;
//
//attribute
//    :   xmlQualifiedName EQUALS xmlQuotedString;
//
//text
//    :   (XMLTemplateText expression ExpressionEnd)+ XMLText?
//    |   XMLText
//    ;
//
//xmlQuotedString
//    :   xmlSingleQuotedString
//    |   xmlDoubleQuotedString
//    ;
//
//xmlSingleQuotedString
//    :   SINGLE_QUOTE (XMLSingleQuotedTemplateString expression ExpressionEnd)* XMLSingleQuotedString? SINGLE_QUOTE_END
//    ;
//
//xmlDoubleQuotedString
//    :   DOUBLE_QUOTE (XMLDoubleQuotedTemplateString expression ExpressionEnd)* XMLDoubleQuotedString? DOUBLE_QUOTE_END
//    ;
//
//xmlQualifiedName
//    :   (XMLQName QNAME_SEPARATOR)? XMLQName
//    |   XMLTagExpressionStart expression ExpressionEnd
//    ;
//
//stringTemplateLiteral
//    :   StringTemplateLiteralStart stringTemplateContent? StringTemplateLiteralEnd
//    ;
//
//stringTemplateContent
//    :   (StringTemplateExpressionStart expression ExpressionEnd)+ StringTemplateText?
//    |   StringTemplateText
//    ;

//AnyIdentifierName ::= identifier | ReservedWord

//ReservedWord ::= foreach | map
