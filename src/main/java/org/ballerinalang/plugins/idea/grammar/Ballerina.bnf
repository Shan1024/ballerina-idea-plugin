/*
 * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

{
  classHeader='CopyrightHeader.txt'

  implements='org.ballerinalang.plugins.idea.psi.BallerinaCompositeElement'
  extends='org.ballerinalang.plugins.idea.psi.impl.BallerinaCompositeElementImpl'

  parserClass="org.ballerinalang.plugins.idea.parser.BallerinaParser"

  psiClassPrefix="Ballerina"
  psiImplClassSuffix="Impl"
  psiPackage="org.ballerinalang.plugins.idea.psi"
  psiImplPackage="org.ballerinalang.plugins.idea.psi.impl"
  psiImplUtilClass="org.ballerinalang.plugins.idea.psi.impl.BallerinaPsiImplUtil"

  elementTypeHolderClass="org.ballerinalang.plugins.idea.psi.BallerinaTypes"
  elementTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaCompositeElementType"

  tokenTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaTokenType"

  tokens=[
    // Todo -  remove keywords after uncommenting all parser rules
    PACKAGE         = 'package'
    IMPORT          = 'import'
    AS              = 'as'
    PUBLIC          = 'public'
    PRIVATE         = 'private'
    NATIVE          = 'native'
    SERVICE         = 'service'
    RESOURCE        = 'resource'
    FUNCTION        = 'function'
    CONNECTOR       = 'connector'
    ACTION          = 'action'
    STRUCT          = 'struct'
    ANNOTATION      = 'annotation'
    ENUM            = 'enum'
    TYPE_PARAMETER  = 'parameter'
    CONST           = 'const'
    TRANSFORMER     = 'transformer'
    WORKER          = 'worker'
    ENDPOINT        = 'endpoint'
    XMLNS           = 'xmlns'
    RETURNS         = 'returns'
    VERSION         = 'version'

    INT             = 'int'
    FLOAT           = 'float'
    BOOLEAN         = 'boolean'
    STRING          = 'string'
    BLOB            = 'blob'
    MAP             = 'map'
    JSON            = 'json'
    XML             = 'xml'
    TABLE           = 'table'
    ANY             = 'any'
    TYPE            = 'type'

    VAR             = 'var'
    CREATE          = 'create'
    ATTACH          = 'attach'
    IF              = 'if'
    ELSE            = 'else'
    FOREACH         = 'foreach'
    WHILE           = 'while'
    NEXT            = 'next'
    BREAK           = 'break'
    FORK            = 'fork'
    JOIN            = 'join'
    SOME            = 'some'
    ALL             = 'all'
    TIMEOUT         = 'timeout'
    TRY             = 'try'
    CATCH           = 'catch'
    FINALLY         = 'finally'
    THROW           = 'throw'
    RETURN          = 'return'
    TRANSACTION     = 'transaction'
    ABORT           = 'abort'
    FAILED          = 'failed'
    RETRIES         = 'retries'
    LENGTHOF        = 'lengthof'
    TYPEOF          = 'typeof'
    WITH            = 'with'
    BIND            = 'bind'
    IN              = 'in'
    LOCK            = 'lock'

    // Separators

    SEMICOLON           = ';'
    COLON               = ':'
    DOT                 = '.'
    COMMA               = ','
    LEFT_BRACE          = '{'
    RIGHT_BRACE         = '}'
    LEFT_PARENTHESIS    = '('
    RIGHT_PARENTHESIS   = ')'
    LEFT_BRACKET        = '['
    RIGHT_BRACKET       = ']'
    QUESTION_MARK       = '?'

    // Arithmetic operators

    ASSIGN  = '='
    ADD     = '+'
    SUB     = '-'
    MUL     = '*'
    DIV     = '/'
    POW     = '^'
    MOD     = '%'

    // Relational operators
    NOT         = '!'
    EQUAL       = '=='
    NOT_EQUAL   = '!='
    GT          = '>'
    LT          = '<'
    GT_EQUAL    = '>='
    LT_EQUAL    = '<='
    AND         = '&&'
    OR          = '||'

    // Additional symbols
    RARROW      = '->'
    LARROW      = '<-'
    AT          = '@'
    BACKTICK    = '`'
    RANGE       = '..'

    WHITE_SPACE = 'regexp:\s+'
    LINE_COMMENT = 'regexp://[^\r\n]*'
    identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    quotedStringLiteral = "regexp:\"(.*)\""
    integerLiteral = "regexp:\d+"
  ]

  extends("(functionInvocation|simpleVariable|mapArrayVariable|fieldVariable|xmlAttribVariable|invocation)Reference")=VariableReference

  extends("(ValueTypeType|BuiltInReferenceTypeType|VariableReference|LambdaFunction|ConnectorInit|TypeCasting|TypeConversion|TypeAccess|Braced)Expression")=Expression
  extends("(Unary|Binary|Ternary)Expression")=Expression
  extends("((Simple|Array|Record)Literal)")=Expression
  extends("Binary(Pow|DivMulMod|AddSub|Compare|Equal|And|Or)Expression")=BinaryExpression

  extends("anyTypeName|typeTypeName|ValueTypeName|ReferenceTypeName|arrayTypeName|BinaryAndExpression")=TypeName

  elementTypeFactory("FunctionDefinition|StructDefinition")='org.ballerinalang.plugins.idea.stubs.BallerinaElementTypeFactory.stubFactory'

  implements("FunctionDefinition|StructDefinition")="org.ballerinalang.plugins.idea.psi.BallerinaNamedElement"
  extends("FunctionDefinition|StructDefinition")="org.ballerinalang.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"

  implements("NameReference")="org.ballerinalang.plugins.idea.psi.BallerinaReferenceExpressionBase"

  generateTokenAccessors=true

}

CompilationUnit ::= PackageDeclaration? (ImportDeclaration | NamespaceDeclaration)* Definition* <<eof>>

PackageDeclaration ::= package PackageName PackageVersion? SEMICOLON {pin=1 /*methods=[getName]*/ /*stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageDeclarationStub"*/}

PackageName ::= identifier (DOT identifier)* {pin(".*")=1}

PackageVersion ::= version identifier {pin=1};

ImportDeclaration ::= import (orgName DIV)? PackageName PackageVersion? Alias? SEMICOLON {pin=1}

orgName ::= identifier

Alias ::= as identifier {pin=1}

// Note - Global variable definition should be the first definition since it can contain identifier as type.
Definition ::= AnnotationAttachment* (StructDefinition | GlobalVariableDefinition | ServiceDefinition | FunctionDefinition | connectorDefinition
               | enumDefinition | AnnotationDefinition  | TransformerDefinition | ConstantDefinition)
               {recoverWhile=TopLevelDefinitionRecover}
private TopLevelDefinitionRecover ::= !(service | function | connector | struct | enum | annotation | transformer | const | boolean | int | float | string | blob | identifier)

ServiceDefinition ::= service (LT identifier GT) identifier ServiceBody {pin=1}
ServiceBody ::=   LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ResourceDefinition* RIGHT_BRACE

ResourceDefinition ::= AnnotationAttachment* resource identifier LEFT_PARENTHESIS ParameterList RIGHT_PARENTHESIS CallableUnitBody {pin=2}

CallableUnitBody ::= LEFT_BRACE BlockWithEndpoint RIGHT_BRACE | LEFT_BRACE EndpointDeclaration* WorkerDeclaration+ RIGHT_BRACE

Block ::= Statement* {recoverWhile=StatementRecover}
BlockWithEndpoint ::= EndpointDeclaration* Block

private StatementRecover ::= !(int | string | '}' | '=')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )


FunctionDefinition ::= NativeFunctionDefinition | NonNativeFunctionDefinition {pin=1 methods=[getIdentifier getName] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaFunctionDefinitionStub"}
private NativeFunctionDefinition ::= (public)? native function receiver? CallableUnitSignature SEMICOLON {pin=3}
private NonNativeFunctionDefinition ::= (public)? function receiver? CallableUnitSignature CallableUnitBody {pin=2}

receiver ::= LT Parameter GT

LambdaFunction ::= function LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? CallableUnitBody {pin=1}

CallableUnitSignature ::= identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? {pin=1}

connectorDefinition ::= (public)? connector identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ConnectorBody {pin=2}

ConnectorBody ::= LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ActionDefinition* RIGHT_BRACE

ActionDefinition ::= NativeActionDefinition | NonNativeActionDefinition
private NativeActionDefinition ::= AnnotationAttachment* native action  CallableUnitSignature SEMICOLON {pin=3}
private NonNativeActionDefinition ::= AnnotationAttachment* action CallableUnitSignature CallableUnitBody {pin=2}

StructDefinition ::= (public)? struct identifier StructBody {pin=2 methods=[getName] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaStructDefinitionStub"}

StructBody ::= LEFT_BRACE FieldDefinition* PrivateStructBody? RIGHT_BRACE

PrivateStructBody ::= PRIVATE COLON FieldDefinition*

AnnotationDefinition ::= (public)? annotation identifier (attach AttachmentPoint (COMMA AttachmentPoint)*)? AnnotationBody {pin=2}

enumDefinition ::= (public)? enum identifier LEFT_BRACE Enumerator (COMMA Enumerator)* RIGHT_BRACE

Enumerator ::= identifier

GlobalVariableDefinition ::= (public)? TypeName identifier (ASSIGN Expression )? SEMICOLON {pin=2}

TransformerDefinition ::= (public)? transformer LT ParameterList GT (identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS)? CallableUnitBody {pin=2}

// Note - "parameter" is treated differently here because there is a parser rule named "parameter" as well.
AttachmentPoint ::= service (LT identifier? GT)? | resource | connector | action | function | struct | enum | const | TYPE_PARAMETER | annotation | transformer

AnnotationBody ::= LEFT_BRACE FieldDefinition* RIGHT_BRACE

ConstantDefinition ::= (public)? const ValueTypeName identifier ASSIGN Expression SEMICOLON {pin=2}

WorkerDeclaration ::= worker identifier LEFT_BRACE Block RIGHT_BRACE {pin=1}

TypeName ::= anyTypeName | typeTypeName | ValueTypeName | ReferenceTypeName | arrayTypeName

BuiltInTypeName ::= any | type | ValueTypeName | BuiltInReferenceTypeName | arrayTypeName

arrayTypeName ::= TypeName (LEFT_BRACKET RIGHT_BRACKET)+

ReferenceTypeName ::= BuiltInReferenceTypeName | UserDefineTypeName | AnonStructTypeName

UserDefineTypeName ::= NameReference

AnonStructTypeName ::= struct StructBody {pin=1}

anyTypeName::= any

typeTypeName::= type

ValueTypeName ::=   boolean | int | float | string | blob

BuiltInReferenceTypeName ::= mapTypeName | xmlTypeName | jsonTypeName | tableTypeName | FunctionTypeName

mapTypeName ::= map (LT TypeName GT)?

xmlTypeName ::= xml (LT (LEFT_BRACE XmlNamespaceName RIGHT_BRACE)? XmlLocalName GT)?

jsonTypeName ::= json (LT NameReference GT)?

tableTypeName ::= table (LT NameReference GT)?

FunctionTypeName ::= function LEFT_PARENTHESIS (ParameterList | TypeList)? RIGHT_PARENTHESIS ReturnParameters?{pin=3}

XmlNamespaceName ::= quotedStringLiteral

XmlLocalName ::= identifier

AnnotationAttachment ::= AT NameReference LEFT_BRACE annotationAttributeList? RIGHT_BRACE {pin=1}

annotationAttributeList ::= AnnotationAttribute (COMMA AnnotationAttribute)*

AnnotationAttribute ::= identifier COLON AnnotationAttributeValue

AnnotationAttributeValue ::= SimpleLiteral | NameReference | AnnotationAttachment | AnnotationAttributeArray

AnnotationAttributeArray ::= LEFT_BRACKET (AnnotationAttributeValue (COMMA AnnotationAttributeValue)*)? RIGHT_BRACKET

// //============================================================================================================
//// STATEMENTS / BLOCKS

// Todo - Add recover rules
Statement ::=
        ExpressionStmt
    |   AssignmentStatement
    |   VariableDefinitionStatement
    |   BindStatement
    |   IfElseStatement
    |   ForeachStatement
    |   WhileStatement
    |   NextStatement
    |   BreakStatement
    |   ForkJoinStatement
    |   TryCatchStatement
    |   ThrowStatement
    |   ReturnStatement
    |   WorkerInteractionStatement
    |   TransactionStatement
    |   AbortStatement
    |   LockStatement
    |   NamespaceDeclarationStatement /*{recoverWhile = StatementRecover}*/

//private StatementRecover ::= !(int | string | '}')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )

VariableDefinitionStatement ::= TypeName identifier (ASSIGN Expression)? SEMICOLON {pin(".*")=1}

RecordLiteral ::= LEFT_BRACE (RecordKeyValue (COMMA RecordKeyValue)*)? RIGHT_BRACE

RecordKeyValue ::= RecordKey COLON Expression

RecordKey ::= identifier | SimpleLiteral

ArrayLiteral ::= LEFT_BRACKET ExpressionList? RIGHT_BRACKET

ConnectorInit ::= create UserDefineTypeName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=1}

EndpointDeclaration ::= EndpointDefinition LEFT_BRACE ((VariableReference | ConnectorInit) SEMICOLON)? RIGHT_BRACE {pin(".*")=1}

EndpointDefinition ::= endpoint (LT NameReference GT) identifier {pin=1}

AssignmentStatement ::= (var)? VariableReferenceList ASSIGN Expression SEMICOLON /*{pin=2}*/

BindStatement ::= bind Expression WITH identifier SEMICOLON {pin=1}

VariableReferenceList ::= VariableReference (COMMA VariableReference)*

IfElseStatement ::= IfClause ElseIfClause* ElseClause? {pin=1}

IfClause ::= if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

ElseIfClause ::= else if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=2}

ElseClause ::= else LEFT_BRACE Block RIGHT_BRACE {pin=1}

ForeachStatement ::= foreach LEFT_PARENTHESIS? VariableReferenceList in (Expression | IntRangeExpression) RIGHT_PARENTHESIS? LEFT_BRACE Block RIGHT_BRACE {pin=1}

IntRangeExpression ::= Expression RANGE Expression | (LEFT_BRACKET|LEFT_PARENTHESIS) Expression RANGE Expression (RIGHT_BRACKET|RIGHT_PARENTHESIS)

WhileStatement ::= while LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=2}

NextStatement ::= next SEMICOLON {pin=1}

BreakStatement ::= break SEMICOLON {pin=1}

// typeName is only message
ForkJoinStatement ::= fork LEFT_BRACE WorkerDeclaration* RIGHT_BRACE JoinClause? TimeoutClause? {pin=1}

// below typeName is only 'message[]'
JoinClause ::= join (LEFT_PARENTHESIS JoinConditions RIGHT_PARENTHESIS)? LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

JoinConditions ::= some integerLiteral (identifier (COMMA identifier)*)? | all (identifier (COMMA identifier)*)? {pin=1}

// below typeName is only 'message[]'
TimeoutClause ::= timeout LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

TryCatchStatement ::= try LEFT_BRACE Block RIGHT_BRACE CatchClauses {pin=1}

CatchClauses ::= CatchClause+ FinallyClause? | FinallyClause

CatchClause ::= catch LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

FinallyClause ::= finally LEFT_BRACE Block RIGHT_BRACE {pin=1}

ThrowStatement ::= throw Expression SEMICOLON {pin=1}

ReturnStatement ::= return ExpressionList? SEMICOLON {pin=1}

WorkerInteractionStatement ::= TriggerWorker | WorkerReply

// below left identifier is of type TYPE_MESSAGE and the right identifier is of type WORKER
TriggerWorker ::= ExpressionList RARROW (identifier | fork) SEMICOLON {pin=2}

// below left identifier is of type WORKER and the right identifier is of type message
WorkerReply ::= ExpressionList LARROW identifier SEMICOLON {pin=2}

// Note - Order of 'simpleVariableReference' and 'functionInvocationReference' because otherwise all function
// invocations will match simpleVariableReference first.
VariableReference ::= invocationReference | mapArrayVariableReference | fieldVariableReference | xmlAttribVariableReference
                      |  functionInvocationReference | simpleVariableReference

invocationReference ::= VariableReference Invocation
mapArrayVariableReference ::= VariableReference Index
fieldVariableReference ::= VariableReference Field
xmlAttribVariableReference ::= VariableReference XmlAttrib
functionInvocationReference ::= FunctionInvocation
simpleVariableReference ::= NameReference

Field ::= DOT identifier

Index ::= LEFT_BRACKET Expression RIGHT_BRACKET

XmlAttrib ::= AT (LEFT_BRACKET Expression RIGHT_BRACKET)?

FunctionInvocation ::= NameReference LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=2}
//{recoverWhile=recover}
//
//private recover::=!(identifier);

Invocation ::= DOT AnyIdentifierName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS

ExpressionList ::= Expression (COMMA Expression)*

ExpressionStmt ::= VariableReference SEMICOLON

TransactionStatement ::= TransactionClause FailedClause?

TransactionClause ::= transaction (WITH TransactionPropertyInitStatementList)? LEFT_BRACE Block RIGHT_BRACE {pin=1}

TransactionPropertyInitStatement ::= RetriesStatement

TransactionPropertyInitStatementList ::= TransactionPropertyInitStatement (COMMA TransactionPropertyInitStatement)*

LockStatement ::= lock LEFT_BRACE Block RIGHT_BRACE {pin=1}

FailedClause ::= failed LEFT_BRACE Block RIGHT_BRACE {pin=1}

AbortStatement ::= abort SEMICOLON {pin=1}

RetriesStatement ::= retries LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS {pin=1}

NamespaceDeclarationStatement ::= NamespaceDeclaration {pin=1}

NamespaceDeclaration ::= xmlns quotedStringLiteral (as identifier)? SEMICOLON {pin=1}

Expression
    ::=  SimpleLiteral
    |   ArrayLiteral
    |   RecordLiteral
//    |   XmlLiteral
//    |   StringTemplateLiteral
    |   ValueTypeTypeExpression
    |   BuiltInReferenceTypeTypeExpression
    |   VariableReferenceExpression
    |   LambdaFunctionExpression
    |   ConnectorInitExpression
    |   TypeCastingExpression
    |   TypeConversionExpression
    |   TypeAccessExpression
    |   UnaryExpression
    |   BracedExpression
    |   BinaryPowExpression
    |   BinaryDivMulModExpression
    |   BinaryAddSubExpression
    |   BinaryCompareExpression
    |   BinaryEqualExpression
    |   BinaryAndExpression
    |   BinaryOrExpression
    |   TernaryExpression {/*pin=1 */ /*recoverWhile=ExpressionRecover*/}

fake BinaryExpression ::= Expression {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

//private ExpressionRecover ::=  !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var )

ValueTypeTypeExpression ::= ValueTypeName DOT identifier
BuiltInReferenceTypeTypeExpression ::= BuiltInReferenceTypeName DOT identifier
VariableReferenceExpression ::= VariableReference
LambdaFunctionExpression ::= LambdaFunction
ConnectorInitExpression ::= ConnectorInit
TypeCastingExpression ::= LEFT_PARENTHESIS TypeName RIGHT_PARENTHESIS Expression
TypeConversionExpression ::= LT TypeName (COMMA FunctionInvocation)? GT Expression
TypeAccessExpression ::= typeof BuiltInTypeName
UnaryExpression ::= (ADD | SUB | NOT | lengthof | typeof) Expression
BracedExpression ::= LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS
BinaryPowExpression ::= Expression POW Expression
BinaryDivMulModExpression ::= Expression (DIV | MUL | MOD) Expression
BinaryAddSubExpression ::= Expression (ADD | SUB) Expression
BinaryCompareExpression ::= Expression (LT_EQUAL | GT_EQUAL | GT | LT) Expression
BinaryEqualExpression ::= Expression (EQUAL | NOT_EQUAL) Expression
BinaryAndExpression ::= Expression AND Expression
BinaryOrExpression ::= Expression OR Expression
TernaryExpression ::= Expression QUESTION_MARK Expression COLON Expression

//reusable productions

NameReference ::= PackageReference? identifier {methods=[getReference getQualifier resolve resolveType]}

PackageReference ::= identifier COLON

ReturnParameters ::= RETURNS? LEFT_PARENTHESIS (ParameterList | TypeList) RIGHT_PARENTHESIS {pin=3}

private TypeList ::= TypeName (COMMA TypeName)* {pin=1 /*recoverWhile=RecoverParameter*/}

ParameterList ::= Parameter (COMMA Parameter)* {pin=1 /*recoverWhile=RecoverParameter*/}

private RecoverParameter ::= !(string | COMMA | RIGHT_PARENTHESIS | identifier)

Parameter ::= AnnotationAttachment* TypeName identifier

FieldDefinition ::= TypeName identifier (ASSIGN SimpleLiteral)? SEMICOLON

SimpleLiteral ::= (ADD|SUB)? integerLiteral /*| (ADD|SUB)? floatingPointLiteral*/ | quotedStringLiteral /*| booleanLiteral | nullLiteral*/ {pin=1}

//// XML parsing
//
//xmlLiteral
//    :   XMLLiteralStart xmlItem XMLLiteralEnd
//    ;
//
//xmlItem
//    :   element
//    |   procIns
//    |   comment
//    |   text
//    |   CDATA
//    ;
//
//content
//    :   text? ((element | CDATA | procIns | comment) text?)*
//    ;
//
//comment
//    :   XML_COMMENT_START (XMLCommentTemplateText expression ExpressionEnd)* XMLCommentText
//    ;
//
//element
//    :   startTag content closeTag
//    |   emptyTag
//    ;
//
//startTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_CLOSE
//    ;
//
//closeTag
//    :   XML_TAG_OPEN_SLASH xmlQualifiedName XML_TAG_CLOSE
//    ;
//
//emptyTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_SLASH_CLOSE
//    ;
//
//procIns
//    :   XML_TAG_SPECIAL_OPEN (XMLPITemplateText expression ExpressionEnd)* XMLPIText
//    ;
//
//attribute
//    :   xmlQualifiedName EQUALS xmlQuotedString;
//
//text
//    :   (XMLTemplateText expression ExpressionEnd)+ XMLText?
//    |   XMLText
//    ;
//
//xmlQuotedString
//    :   xmlSingleQuotedString
//    |   xmlDoubleQuotedString
//    ;
//
//xmlSingleQuotedString
//    :   SINGLE_QUOTE (XMLSingleQuotedTemplateString expression ExpressionEnd)* XMLSingleQuotedString? SINGLE_QUOTE_END
//    ;
//
//xmlDoubleQuotedString
//    :   DOUBLE_QUOTE (XMLDoubleQuotedTemplateString expression ExpressionEnd)* XMLDoubleQuotedString? DOUBLE_QUOTE_END
//    ;
//
//xmlQualifiedName
//    :   (XMLQName QNAME_SEPARATOR)? XMLQName
//    |   XMLTagExpressionStart expression ExpressionEnd
//    ;
//
//stringTemplateLiteral
//    :   StringTemplateLiteralStart stringTemplateContent? StringTemplateLiteralEnd
//    ;
//
//stringTemplateContent
//    :   (StringTemplateExpressionStart expression ExpressionEnd)+ StringTemplateText?
//    |   StringTemplateText
//    ;

AnyIdentifierName ::= identifier | ReservedWord

ReservedWord ::= foreach | map
