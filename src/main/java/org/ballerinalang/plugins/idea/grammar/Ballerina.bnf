/*
 * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

{
  classHeader='CopyrightHeader.txt'

  implements='org.ballerinalang.plugins.idea.psi.BallerinaCompositeElement'
  extends='org.ballerinalang.plugins.idea.psi.impl.BallerinaCompositeElementImpl'

  parserClass="org.ballerinalang.plugins.idea.parser.BallerinaParser"

  psiClassPrefix="Ballerina"
  psiImplClassSuffix="Impl"
  psiPackage="org.ballerinalang.plugins.idea.psi"
  psiImplPackage="org.ballerinalang.plugins.idea.psi.impl"
  psiImplUtilClass="org.ballerinalang.plugins.idea.psi.impl.BallerinaPsiImplUtil"

  elementTypeHolderClass="org.ballerinalang.plugins.idea.psi.BallerinaTypes"
  elementTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaCompositeElementType"

  tokenTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaTokenType"

  tokens=[
    // Todo -  remove keywords after uncommenting all parser rules
    PACKAGE         = 'package'
    IMPORT          = 'import'
    AS              = 'as'
    PUBLIC          = 'public'
    PRIVATE         = 'private'
    NATIVE          = 'native'
    SERVICE         = 'service'
    RESOURCE        = 'resource'
    FUNCTION        = 'function'
    CONNECTOR       = 'connector'
    ACTION          = 'action'
    STRUCT          = 'struct'
    ANNOTATION      = 'annotation'
    ENUM            = 'enum'
    TYPE_PARAMETER  = 'parameter'
    CONST           = 'const'
    TRANSFORMER     = 'transformer'
    WORKER          = 'worker'
    ENDPOINT        = 'endpoint'
    XMLNS           = 'xmlns'
    RETURNS         = 'returns'
    VERSION         = 'version'

    INT             = 'int'
    FLOAT           = 'float'
    BOOLEAN         = 'boolean'
    STRING          = 'string'
    BLOB            = 'blob'
    MAP             = 'map'
    JSON            = 'json'
    XML             = 'xml'
    TABLE           = 'table'
    ANY             = 'any'
    TYPE            = 'type'

    VAR             = 'var'
    CREATE          = 'create'
    ATTACH          = 'attach'
    IF              = 'if'
    ELSE            = 'else'
    FOREACH         = 'foreach'
    WHILE           = 'while'
    NEXT            = 'next'
    BREAK           = 'break'
    FORK            = 'fork'
    JOIN            = 'join'
    SOME            = 'some'
    ALL             = 'all'
    TIMEOUT         = 'timeout'
    TRY             = 'try'
    CATCH           = 'catch'
    FINALLY         = 'finally'
    THROW           = 'throw'
    RETURN          = 'return'
    TRANSACTION     = 'transaction'
    ABORT           = 'abort'
    FAILED          = 'failed'
    RETRIES         = 'retries'
    LENGTHOF        = 'lengthof'
    TYPEOF          = 'typeof'
    WITH            = 'with'
    BIND            = 'bind'
    IN              = 'in'
    LOCK            = 'lock'

    // Separators

    SEMICOLON           = ';'
    COLON               = ':'
    DOT                 = '.'
    COMMA               = ','
    LEFT_BRACE          = '{'
    RIGHT_BRACE         = '}'
    LEFT_PARENTHESIS    = '('
    RIGHT_PARENTHESIS   = ')'
    LEFT_BRACKET        = '['
    RIGHT_BRACKET       = ']'
    QUESTION_MARK       = '?'

    // Arithmetic operators

    ASSIGN  = '='
    ADD     = '+'
    SUB     = '-'
    MUL     = '*'
    DIV     = '/'
    POW     = '^'
    MOD     = '%'

    // Relational operators
    NOT         = '!'
    EQUAL       = '=='
    NOT_EQUAL   = '!='
    GT          = '>'
    LT          = '<'
    GT_EQUAL    = '>='
    LT_EQUAL    = '<='
    AND         = '&&'
    OR          = '||'

    // Additional symbols
    RARROW      = '->'
    LARROW      = '<-'
    AT          = '@'
    BACKTICK    = '`'
    RANGE       = '..'

    WHITE_SPACE = 'regexp:\s+'
    LINE_COMMENT = 'regexp://[^\r\n]*'
    identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    quotedStringLiteral = "regexp:\"(.*)\""
    integerLiteral = "regexp:\d+"
  ]

  extends("(FunctionInvocation|SimpleVariable|MapArrayVariable|FieldVariable|XmlAttribVariable|Invocation)Reference")=VariableReference

  extends("((ValueType|BuiltInReferenceType)Type|VariableReference|LambdaFunction|TypeInit|Type(Casting|Conversion|Access)|Braced)Expression")=Expression
  extends("(Unary|Binary|Ternary)Expression")=Expression
  extends("((Simple|Array|Record|Xml|StringTemplate)Literal)")=Expression
  extends("Binary(Pow|DivMulMod|AddSub|Compare|Equal|And|Or)Expression")=BinaryExpression

  extends("(AnyType|TypeType|ValueType|ReferenceType|arrayType)Name|BinaryAndExpression")=TypeName

  implements("(Function|Struct|GlobalVariable|Connector)Definition")="org.ballerinalang.plugins.idea.psi.BallerinaNamedElement"
  extends("(Function|Struct|GlobalVariable|Connector)Definition")="org.ballerinalang.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"

  elementTypeFactory("(Function|Struct|GlobalVariable|Connector)Definition")='org.ballerinalang.plugins.idea.stubs.BallerinaElementTypeFactory.stubFactory'

//  implements("NameReference")="com.intellij.psi.PsiNameIdentifierOwner"

  generateTokenAccessors=true
}

CompilationUnit ::= PackageDeclaration? (ImportDeclaration | NamespaceDeclaration)* Definition* <<eof>>

PackageDeclaration ::= package CompletePackageName SEMICOLON {pin=1 /*methods=[getName]*/ /*stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageDeclarationStub"*/}

// Todo - Cache
CompletePackageName ::= PackageName (DOT PackageName)* PackageVersion? {pin(".*")=1}

// Todo - Cache
PackageName ::= identifier

// Todo - Cache
PackageVersion ::= version identifier {pin=1};

// Todo - Cache
ImportDeclaration ::= import (orgName DIV)? CompletePackageName Alias? SEMICOLON {pin=1}

// Todo - Cache
orgName ::= identifier

// Todo - Cache
Alias ::= as identifier {pin=1}

// Note - Global variable definition should be the first definition since it can contain identifier as type.
Definition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment?
               (StructDefinition | GlobalVariableDefinition | ServiceDefinition | FunctionDefinition
                | ConnectorDefinition | enumDefinition | AnnotationDefinition | TransformerDefinition
                | ConstantDefinition | GlobalEndpointDefinition) {recoverWhile=TopLevelDefinitionRecover}

private TopLevelDefinitionRecover ::= !(service | function | connector | struct | enum | annotation | transformer | const | boolean | int | float | string | blob | identifier)

ServiceDefinition ::= service (LT NameReference GT) identifier ServiceBody {pin=1}
ServiceBody ::=   LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ResourceDefinition* RIGHT_BRACE

ResourceDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? resource identifier LEFT_PARENTHESIS ParameterList RIGHT_PARENTHESIS CallableUnitBody {pin=4}

CallableUnitBody ::= LEFT_BRACE BlockWithEndpoint RIGHT_BRACE | LEFT_BRACE EndpointDeclaration* WorkerDeclaration+ RIGHT_BRACE

Block ::= Statement* {recoverWhile=StatementRecover}
BlockWithEndpoint ::= EndpointDeclaration* Block

private StatementRecover ::= !(int | string | '}' | '=')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )

FunctionDefinition ::= NativeFunctionDefinition | NonNativeFunctionDefinition {pin=1 methods=[getIdentifier getName] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaFunctionDefinitionStub"}
private NativeFunctionDefinition ::= (public)? native function (LT Parameter GT)? CallableUnitSignature SEMICOLON {pin=3}
private NonNativeFunctionDefinition ::= (public)? function (LT Parameter GT)? CallableUnitSignature CallableUnitBody {pin=2}

LambdaFunction ::= function LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? CallableUnitBody {pin=1}

// Todo - cache. Signature owner
CallableUnitSignature ::= identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ReturnParameters? {pin=1}

ConnectorDefinition ::= (public)? connector identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS ConnectorBody {pin=2 stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaConnectorDefinitionStub"}

ConnectorBody ::= LEFT_BRACE EndpointDeclaration* VariableDefinitionStatement* ActionDefinition* RIGHT_BRACE

ActionDefinition ::= NativeActionDefinition | NonNativeActionDefinition
private NativeActionDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? native action  CallableUnitSignature SEMICOLON {pin=5}
private NonNativeActionDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? action CallableUnitSignature CallableUnitBody {pin=4}

StructDefinition ::= (public)? struct identifier StructBody {pin=2 methods=[getName] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaStructDefinitionStub"}

StructBody ::= LEFT_BRACE FieldDefinition* PrivateStructBody? RIGHT_BRACE

// Todo - Cache
PrivateStructBody ::= private COLON FieldDefinition* {pin=1}

AnnotationDefinition ::= (public)? annotation (LT AttachmentPoint (COMMA AttachmentPoint)* GT)?  identifier UserDefineTypeName? SEMICOLON {pin=2}

enumDefinition ::= (public)? enum identifier LEFT_BRACE Enumerator (COMMA Enumerator)* RIGHT_BRACE {pin=2}

Enumerator ::= identifier

GlobalVariableDefinition ::= (public)? TypeName identifier (ASSIGN Expression )? SEMICOLON {pin=2 stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaGlobalVariableDefinitionStub"}

TransformerDefinition ::= (public)? transformer LT ParameterList GT (identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS)? CallableUnitBody {pin=2}

// Todo - Need to update the service?
// Note - "parameter" is treated differently here because there is a parser rule named "parameter" as well.
AttachmentPoint ::= service (LT identifier? GT)? | resource | connector | action | function | struct | enum | const | TYPE_PARAMETER | annotation | transformer

ConstantDefinition ::= (public)? const ValueTypeName identifier ASSIGN Expression SEMICOLON {pin=2}

WorkerDeclaration ::= worker identifier LEFT_BRACE Block RIGHT_BRACE {pin=1}

GlobalEndpointDefinition ::= public? EndpointDeclaration

EndpointDeclaration ::= AnnotationAttachment* endpoint (LT NameReference GT) identifier RecordLiteral? {pin=2}

TypeName ::= AnyTypeName | TypeTypeName | ValueTypeName | ReferenceTypeName | arrayTypeName

BuiltInTypeName ::= AnyTypeName | TypeTypeName | ValueTypeName | BuiltInReferenceTypeName | arrayTypeName

arrayTypeName ::= TypeName (LEFT_BRACKET RIGHT_BRACKET)+

ReferenceTypeName ::= BuiltInReferenceTypeName | UserDefineTypeName | AnonStructTypeName

UserDefineTypeName ::= NameReference

AnonStructTypeName ::= struct StructBody {pin=1}

AnyTypeName::= any

TypeTypeName::= type

ValueTypeName ::=   boolean | int | float | string | blob

BuiltInReferenceTypeName ::= MapTypeName | XmlTypeName | JsonTypeName | TableTypeName | FunctionTypeName

MapTypeName ::= map (LT TypeName GT)? {pin=1}

XmlTypeName ::= xml (LT (LEFT_BRACE XmlNamespaceName RIGHT_BRACE)? XmlLocalName GT)? {pin=1}

JsonTypeName ::= json (LT NameReference GT)? {pin=1}

TableTypeName ::= table (LT NameReference GT)? {pin=1}

// Todo - Pin 1?
FunctionTypeName ::= function LEFT_PARENTHESIS (ParameterList | TypeList)? RIGHT_PARENTHESIS ReturnParameters? {pin=3}

XmlNamespaceName ::= quotedStringLiteral

XmlLocalName ::= identifier

// Todo - Cache
AnnotationAttachment ::= AT NameReference RecordLiteral?


// STATEMENTS / BLOCKS =================================================================================================

// Todo - Add recovery rules
Statement ::=
        ExpressionStmt
    |   AssignmentStatement
    |   VariableDefinitionStatement
    |   IfElseStatement
    |   ForeachStatement
    |   WhileStatement
    |   NextStatement
    |   BreakStatement
    |   ForkJoinStatement
    |   TryCatchStatement
    |   ThrowStatement
    |   ReturnStatement
    |   WorkerInteractionStatement
    |   TransactionStatement
    |   AbortStatement
    |   LockStatement
    |   NamespaceDeclarationStatement /*{recoverWhile = StatementRecover}*/

//private StatementRecover ::= !(int | string | '}')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )

VariableDefinitionStatement ::= TypeName identifier (ASSIGN (Expression | ActionInvocation))? SEMICOLON {pin(".*")=1}

RecordLiteral ::= LEFT_BRACE (RecordKeyValue (COMMA RecordKeyValue)*)? RIGHT_BRACE

RecordKeyValue ::= RecordKey COLON Expression

RecordKey ::= identifier | SimpleLiteral

ArrayLiteral ::= LEFT_BRACKET ExpressionList? RIGHT_BRACKET

TypeInitExpression ::= new UserDefineTypeName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=1}

AssignmentStatement ::= (var)? VariableReferenceList ASSIGN (Expression | ActionInvocation) SEMICOLON /*{pin=2}*/

VariableReferenceList ::= VariableReference (COMMA VariableReference)*

IfElseStatement ::= IfClause ElseIfClause* ElseClause? {pin=1}

IfClause ::= if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

ElseIfClause ::= else if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=2}

ElseClause ::= else LEFT_BRACE Block RIGHT_BRACE {pin=1}

ForeachStatement ::= foreach LEFT_PARENTHESIS? VariableReferenceList in (Expression | IntRangeExpression) RIGHT_PARENTHESIS? LEFT_BRACE Block RIGHT_BRACE {pin=1}

IntRangeExpression ::= Expression RANGE Expression | (LEFT_BRACKET|LEFT_PARENTHESIS) Expression RANGE Expression (RIGHT_BRACKET|RIGHT_PARENTHESIS)

// Todo - pin 1?
WhileStatement ::= while LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=2}

NextStatement ::= next SEMICOLON {pin=1}

BreakStatement ::= break SEMICOLON {pin=1}

// typeName is only message
ForkJoinStatement ::= fork LEFT_BRACE WorkerDeclaration* RIGHT_BRACE JoinClause? TimeoutClause? {pin=1}

// below typeName is only 'message[]'
JoinClause ::= join (LEFT_PARENTHESIS JoinConditions RIGHT_PARENTHESIS)? LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

// Todo - Needs reorder?
JoinConditions ::= (some integerLiteral | all) (identifier (COMMA identifier)*)? {pin=1}

// below typeName is only 'message[]'
TimeoutClause ::= timeout LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

TryCatchStatement ::= try LEFT_BRACE Block RIGHT_BRACE CatchClauses {pin=1}

CatchClauses ::= CatchClause+ FinallyClause? | FinallyClause

CatchClause ::= catch LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

FinallyClause ::= finally LEFT_BRACE Block RIGHT_BRACE {pin=1}

ThrowStatement ::= throw Expression SEMICOLON {pin=1}

ReturnStatement ::= return ExpressionList? SEMICOLON {pin=1}

WorkerInteractionStatement ::= TriggerWorker | WorkerReply

// below left identifier is of type TYPE_MESSAGE and the right identifier is of type WORKER
TriggerWorker ::= ExpressionList RARROW (identifier | fork) SEMICOLON {pin=2}

// below left identifier is of type WORKER and the right identifier is of type message
WorkerReply ::= ExpressionList LARROW identifier SEMICOLON {pin=2}

// Note - Order of 'simpleVariableReference' and 'functionInvocationReference' because otherwise all function
// invocations will match simpleVariableReference first.
VariableReference ::= InvocationReference | MapArrayVariableReference | FieldVariableReference | XmlAttribVariableReference
                      |  FunctionInvocationReference | SimpleVariableReference

InvocationReference ::= VariableReference Invocation
MapArrayVariableReference ::= VariableReference Index
FieldVariableReference ::= VariableReference Field
XmlAttribVariableReference ::= VariableReference XmlAttrib
FunctionInvocationReference ::= FunctionInvocation
SimpleVariableReference ::= NameReference

Field ::= DOT identifier {pin=1}

Index ::= LEFT_BRACKET Expression RIGHT_BRACKET {pin=1}

XmlAttrib ::= AT (LEFT_BRACKET Expression RIGHT_BRACKET)? {pin=1}

// Todo - Need to pin?
FunctionInvocation ::= NameReference LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS /*{pin=2}*/

Invocation ::= DOT AnyIdentifierName LEFT_PARENTHESIS ExpressionList? RIGHT_PARENTHESIS {pin=1}

ActionInvocation ::= VariableReference RARROW FunctionInvocation {pin=2}

ExpressionList ::= Expression (COMMA Expression)*

ExpressionStmt ::= (VariableReference | ActionInvocation) SEMICOLON

TransactionStatement ::= TransactionClause FailedClause?

TransactionClause ::= transaction (WITH TransactionPropertyInitStatementList)? LEFT_BRACE Block RIGHT_BRACE {pin=1}

TransactionPropertyInitStatement ::= RetriesStatement

TransactionPropertyInitStatementList ::= TransactionPropertyInitStatement (COMMA TransactionPropertyInitStatement)*

LockStatement ::= lock LEFT_BRACE Block RIGHT_BRACE {pin=1}

FailedClause ::= failed LEFT_BRACE Block RIGHT_BRACE {pin=1}

AbortStatement ::= abort SEMICOLON {pin=1}

RetriesStatement ::= retries LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS {pin=1}

NamespaceDeclarationStatement ::= NamespaceDeclaration /*{pin=1}*/

NamespaceDeclaration ::= xmlns quotedStringLiteral (as identifier)? SEMICOLON {pin=1}

Expression
    ::=  SimpleLiteral
    |   ArrayLiteral
    |   RecordLiteral
    |   XmlLiteral
    |   StringTemplateLiteral
    |   ValueTypeTypeExpression
    |   BuiltInReferenceTypeTypeExpression
    |   VariableReferenceExpression
    |   LambdaFunctionExpression
    |   TypeInitExpression
    |   TypeCastingExpression
    |   TypeConversionExpression
    |   TypeAccessExpression
    |   UnaryExpression
    |   BracedExpression
    |   BinaryPowExpression
    |   BinaryDivMulModExpression
    |   BinaryAddSubExpression
    |   BinaryCompareExpression
    |   BinaryEqualExpression
    |   BinaryAndExpression
    |   BinaryOrExpression
    |   TernaryExpression {/*pin=1 */ /*recoverWhile=ExpressionRecover*/}

fake BinaryExpression ::= Expression {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

//private ExpressionRecover ::=  !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var )

ValueTypeTypeExpression ::= ValueTypeName DOT identifier
BuiltInReferenceTypeTypeExpression ::= BuiltInReferenceTypeName DOT identifier
VariableReferenceExpression ::= VariableReference
LambdaFunctionExpression ::= LambdaFunction
TypeCastingExpression ::= LEFT_PARENTHESIS TypeName RIGHT_PARENTHESIS Expression
TypeConversionExpression ::= LT TypeName (COMMA FunctionInvocation)? GT Expression
TypeAccessExpression ::= typeof BuiltInTypeName
UnaryExpression ::= (ADD | SUB | NOT | lengthof | typeof) Expression
BracedExpression ::= LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS
BinaryPowExpression ::= Expression POW Expression
BinaryDivMulModExpression ::= Expression (DIV | MUL | MOD) Expression
BinaryAddSubExpression ::= Expression (ADD | SUB) Expression
BinaryCompareExpression ::= Expression (LT_EQUAL | GT_EQUAL | GT | LT) Expression
BinaryEqualExpression ::= Expression (EQUAL | NOT_EQUAL) Expression
BinaryAndExpression ::= Expression AND Expression
BinaryOrExpression ::= Expression OR Expression
TernaryExpression ::= Expression QUESTION_MARK Expression COLON Expression

//reusable productions

NameReference ::= PackageReference? identifier /*{methods=[getReference getQualifier resolve resolveType]}*/

PackageReference ::= identifier COLON

ReturnParameters ::= RETURNS? LEFT_PARENTHESIS (ParameterList | parameterTypeNameList) RIGHT_PARENTHESIS {pin=3}

parameterTypeNameList ::= parameterTypeName (COMMA parameterTypeName)* {pin=1 /*recoverWhile=RecoverParameter*/}

parameterTypeName ::= AnnotationAttachment* TypeName

ParameterList ::= Parameter (COMMA Parameter)* {pin=1 /*recoverWhile=RecoverParameter*/}

//private RecoverParameter ::= !(string | COMMA | RIGHT_PARENTHESIS | identifier)

Parameter ::= AnnotationAttachment* TypeName identifier

// Todo - cache
FieldDefinition ::= TypeName identifier (ASSIGN SimpleLiteral)? SEMICOLON {pin=1}

SimpleLiteral ::= (ADD|SUB)? integerLiteral /*| (ADD|SUB)? floatingPointLiteral*/ | quotedStringLiteral /*| booleanLiteral | nullLiteral*/ {pin=1}

// XML parsing

XmlLiteral ::= XMLLiteralStart XmlItem XMLLiteralEnd

XmlItem ::= Element | ProcIns | Comment | XmlText | CDATA

Content ::= XmlText? ((Element | CDATA | ProcIns | Comment) XmlText?)*

Comment ::= XML_COMMENT_START (XMLCommentTemplateText Expression ExpressionEnd)* XMLCommentText

Element ::= StartTag Content CloseTag | EmptyTag

StartTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_CLOSE

CloseTag ::= XML_TAG_OPEN_SLASH XmlQualifiedName XML_TAG_CLOSE

EmptyTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_SLASH_CLOSE

ProcIns ::= XML_TAG_SPECIAL_OPEN (XMLPITemplateText Expression ExpressionEnd)* XMLPIText

Attribute ::= XmlQualifiedName EQUALS XmlQuotedString;

XmlText ::= (XMLTemplateText Expression ExpressionEnd)+ XMLText? | XMLText

XmlQuotedString ::= XmlSingleQuotedString | XmlDoubleQuotedString

XmlSingleQuotedString ::= SINGLE_QUOTE (XMLSingleQuotedTemplateString Expression ExpressionEnd)* XMLSingleQuotedString? SINGLE_QUOTE_END

XmlDoubleQuotedString ::= DOUBLE_QUOTE (XMLDoubleQuotedTemplateString Expression ExpressionEnd)* XMLDoubleQuotedString? DOUBLE_QUOTE_END

XmlQualifiedName ::= (XMLQName QNAME_SEPARATOR)? XMLQName | XMLTagExpressionStart Expression ExpressionEnd

StringTemplateLiteral ::= StringTemplateLiteralStart StringTemplateContent? StringTemplateLiteralEnd

StringTemplateContent ::= (StringTemplateExpressionStart Expression ExpressionEnd)+ StringTemplateText? | StringTemplateText

AnyIdentifierName ::= identifier | ReservedWord

ReservedWord ::= foreach | map


// Deprecated parsing.

deprecatedAttachment ::= DeprecatedTemplateStart deprecatedText? DeprecatedTemplateEnd

deprecatedText ::= deprecatedTemplateInlineCode (DeprecatedTemplateText | deprecatedTemplateInlineCode)*
                   | DeprecatedTemplateText (DeprecatedTemplateText | deprecatedTemplateInlineCode)*

deprecatedTemplateInlineCode ::= singleBackTickDeprecatedInlineCode | doubleBackTickDeprecatedInlineCode | tripleBackTickDeprecatedInlineCode

singleBackTickDeprecatedInlineCode ::= SBDeprecatedInlineCodeStart SingleBackTickInlineCode? SingleBackTickInlineCodeEnd

doubleBackTickDeprecatedInlineCode ::= DBDeprecatedInlineCodeStart DoubleBackTickInlineCode? DoubleBackTickInlineCodeEnd

tripleBackTickDeprecatedInlineCode ::= TBDeprecatedInlineCodeStart TripleBackTickInlineCode? TripleBackTickInlineCodeEnd


// Documentation parsing.

documentationAttachment ::= DocumentationTemplateStart documentationTemplateContent? DocumentationTemplateEnd

documentationTemplateContent ::= docText? documentationTemplateAttributeDescription+ | docText

documentationTemplateAttributeDescription ::= DocumentationTemplateAttributeStart Identifier DocumentationTemplateAttributeEnd docText?

docText ::= documentationTemplateInlineCode (DocumentationTemplateText | documentationTemplateInlineCode)*
            | DocumentationTemplateText  (DocumentationTemplateText | documentationTemplateInlineCode)*

documentationTemplateInlineCode ::= singleBackTickDocInlineCode | doubleBackTickDocInlineCode | tripleBackTickDocInlineCode

singleBackTickDocInlineCode ::= SBDocInlineCodeStart SingleBackTickInlineCode? SingleBackTickInlineCodeEnd

doubleBackTickDocInlineCode ::= DBDocInlineCodeStart DoubleBackTickInlineCode? DoubleBackTickInlineCodeEnd

tripleBackTickDocInlineCode ::= TBDocInlineCodeStart TripleBackTickInlineCode? TripleBackTickInlineCodeEnd
