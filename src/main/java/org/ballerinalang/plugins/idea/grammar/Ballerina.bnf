/*
 * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

{
    classHeader = "CopyrightHeader.txt"

    implements = "org.ballerinalang.plugins.idea.psi.BallerinaCompositeElement"
    extends = "org.ballerinalang.plugins.idea.psi.impl.BallerinaCompositeElementImpl"

    parserClass = "org.ballerinalang.plugins.idea.parser.BallerinaParser"
  parserUtilClass="org.ballerinalang.plugins.idea.parser.BallerinaParserUtil"

    psiClassPrefix = "Ballerina"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.ballerinalang.plugins.idea.psi"
    psiImplPackage = "org.ballerinalang.plugins.idea.psi.impl"
    psiImplUtilClass = "org.ballerinalang.plugins.idea.psi.impl.BallerinaPsiImplUtil"

    elementTypeHolderClass = "org.ballerinalang.plugins.idea.psi.BallerinaTypes"
    elementTypeClass = "org.ballerinalang.plugins.idea.psi.BallerinaCompositeElementType"

    tokenTypeClass = "org.ballerinalang.plugins.idea.psi.BallerinaTokenType"

    tokens = [

        DOCUMENTATION       = 'documentation';
        DEPRECATED          = 'deprecated';

        // Separators
        SEMICOLON           = ';' ;
        COLON               = ':' ;
        DOUBLE_COLON        = '::' ;
        DOT                 = '.' ;
        COMMA               = ',' ;
        LEFT_BRACE          = '{' ;
        RIGHT_BRACE         = '}' ;
        LEFT_PARENTHESIS    = '(' ;
        RIGHT_PARENTHESIS   = ')' ;
        LEFT_BRACKET        = '[' ;
        RIGHT_BRACKET       = ']' ;
        QUESTION_MARK       = '?' ;

        // Arithmetic operators
        ASSIGN              = '=' ;
        ADD                 = '+' ;
        SUB                 = '-' ;
        MUL                 = '*' ;
        DIV                 = '/' ;
        POW                 = '^' ;
        MOD                 = '%';

        // Relational operators
        NOT                 = '!' ;
        EQUAL               = '==' ;
        NOT_EQUAL           = '!=' ;
        GT                  = '>' ;
        LT                  = '<' ;
        GT_EQUAL            = '>=' ;
        LT_EQUAL            = '<=' ;
        AND                 = '&&' ;
        OR                  = '||' ;

        // Additional symbols
        RARROW              = '->' ;
        LARROW              = '<-' ;
        AT                  = '@' ;
        BACKTICK            = '`' ;
        RANGE               = '..' ;
        ELLIPSIS            = '...' ;
        PIPE                = '|' ;
        EQUAL_GT            = '=>' ;

        // Compound Assignment operators.
        COMPOUND_ADD        = '+=' ;
        COMPOUND_SUB        = '-=' ;
        COMPOUND_MUL        = '*=' ;
        COMPOUND_DIV        = '/=' ;

        // Safe assignment operator
        SAFE_ASSIGNMENT     = '=?' ;

        // Post Arithmetic operators.
        INCREMENT           = '++' ;
        DECREMENT           = '--' ;

        LINE_COMMENT        = 'regexp://[^\r\n]*'

        WHITE_SPACE = 'regexp:\s+'
        identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'

        //        QUOTED_STRING_LITERAL = "regexp:\"(.*?)\""
        //        INTEGER_LITERAL = "regexp:\d+"

        //    string_template_literal_start = "regexp:string\s*`"
        //    string_template_literal_end = "`"

        //    string_template_expression_start = "{{"
        //    string_template_expression_end = "}}"
  ]

    extends("(FunctionInvocation|SimpleVariable|MapArrayVariable|FieldVariable|XmlAttribVariable|Invocation|AwaitExpression)Reference") = VariableReference

    extends("((Simple|Array|Record|Xml|StringTemplate)Literal|(ValueType|BuiltInReferenceType)Type|VariableReference|LambdaFunction|TypeInit|Type(Casting|Conversion|Access)|BracedOrTuple|Await)Expression") = Expression
    extends("(Unary|Binary|Ternary)Expression") = Expression

    extends("Binary(Pow|DivMulMod|AddSub|Compare|Equal|And|Or)Expression") = BinaryExpression

    extends("(Simple|Array|Nullable|Union|Group|Tuple|Annotated|Object)TypeName|BinaryAndExpression") = TypeName

    // Each named definition which can be renamed should implement this interface.
    implements("(Function|Struct|GlobalVariable|Connector|Enum|Annotation|Transformer|Constant|(.*Endpoint)|Action|Worker)Definition") = "org.ballerinalang.plugins.idea.psi.BallerinaNamedElement"
    // Each named definition should extend this class.
    extends("(Function|Struct|GlobalVariable|Connector|Enum|Annotation|Transformer|Constant|(.*Endpoint)|Action|Worker)Definition") = "org.ballerinalang.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"

    // Each stubbed element should have this element type factory.
    elementTypeFactory("PackageDeclaration|(Function|Struct|GlobalVariable|Connector|Enum|Annotation|Transformer|Constant|(.*Endpoint)|Action|Worker)Definition") = "org.ballerinalang.plugins.idea.stubs.factory.BallerinaElementTypeFactory.stubFactory"

    // Each stub which is not a named definition should extend this class.
    extends("PackageDeclaration") = "org.ballerinalang.plugins.idea.psi.impl.BallerinaStubbedElementImpl<?>"

    // "|NamespaceDeclaration|ParameterList|ParameterTypeNameList|CallableUnitSignature|ParameterTypeNameList|ReturnParameters"
    // Todo - Add CatchClause, TriggerWorker, WorkerReply?
    // Each named element (which can be renamed) should implement this interface.
    implements("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|Enumerator|VariableDefinitionStatement|Field(Definition)?|NamespaceDeclaration") = "org.ballerinalang.plugins.idea.psi.BallerinaNamedElement"
    // Each named element should extend this class.
    extends("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|Enumerator|VariableDefinitionStatement|Field(Definition)?|NamespaceDeclaration") = "org.ballerinalang.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"
    // Each stubbed element should have this element type factory.
    elementTypeFactory("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|Enumerator|VariableDefinitionStatement|Field(Definition)?|NamespaceDeclaration") = "org.ballerinalang.plugins.idea.stubs.factory.BallerinaElementTypeFactory.stubFactory"

    implements("NameReference") = "org.ballerinalang.plugins.idea.psi.BallerinaReferenceExpressionBase"

    generateTokenAccessors = true
}

CompilationUnit ::= PackageDeclaration? (ImportDeclaration | NamespaceDeclaration)* Definition* <<eof>>

PackageDeclaration ::= package CompletePackageName PackageVersion? SEMICOLON {
    pin=1
    methods=[getName]
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageDeclarationStub"
}

CompletePackageName ::= PackageName (DOT PackageName)* {
    pin(".*")=1
    methods=[getReferences]
}

PackageName ::= identifier {
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageNameStub"
}

PackageVersion ::= version identifier {
    pin=1
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageVersionStub"
}

// Todo - Cache
ImportDeclaration ::= import (OrgName DIV)? CompletePackageName PackageVersion? Alias? SEMICOLON {
    pin=1
    methods=[getShortPackageName]
}

OrgName ::= identifier {
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaOrgNameStub"
}

Alias ::= as identifier {
    pin=1 stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaAliasStub"
}

// Note - Global variable definition should be the first definition since it can contain identifier as type.
Definition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment?
               ( TypeDefinition
               | StructDefinition
               | GlobalVariableDefinition
               | ServiceDefinition
               | FunctionDefinition
               | EnumDefinition
               | AnnotationDefinition
               | TransformerDefinition
               | ConstantDefinition
               | GlobalEndpointDefinition
               ) {
    recoverWhile=TopLevelDefinitionRecover
}

private TopLevelDefinitionRecover ::= !(DOCUMENTATION_TEMPLATE_START|DEPRECATED_TEMPLATE_START|'@'|public|type|typedesc|struct|service|function|enum|annotation|transformer|const|endpoint|int|float|boolean|string|blob|map|xml|xmlns|json|table|identifier)

ServiceDefinition ::= service (LT NameReference GT) identifier ServiceEndpointAttachments?  ServiceBody {pin=1}
ServiceEndpointAttachments ::= bind NameReference (COMMA NameReference)* {pin=1}
ServiceBody ::= LEFT_BRACE (/*ResourceDefinition+ | EndpointDefinition+ ResourceDefinition* |*/ EndpointDefinition* VariableDefinitionStatementInService* ResourceDefinition*) RIGHT_BRACE /*{pin=1}*/

VariableDefinitionStatementInService ::= /*<<isNotAResourceDefinition>> VariableDefinitionStatement*/TypeName identifier ((ASSIGN | SAFE_ASSIGNMENT) (ActionInvocation | Expression))? SEMICOLON
ResourceDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? identifier LEFT_PARENTHESIS resourceParameterList? RIGHT_PARENTHESIS CallableUnitBody {pin=4}
resourceParameterList ::= endpointParameter | ParameterList
endpointParameter ::= endpoint identifier (COMMA ParameterList)? {pin(".*")=1}

// Pin to make sure callable unit is identified correctly
CallableUnitBody ::= LEFT_BRACE (BlockWithEndpoint RIGHT_BRACE | BlockWithEndpointAndWorker RIGHT_BRACE)  {pin=1}

Block ::= Statement* {methods=[processDeclarations]} /*{recoverWhile=StatementRecover}*/
BlockWithEndpoint ::= EndpointDefinition* Statement* {elementType=Block}
BlockWithEndpointAndWorker ::= EndpointDefinition* WorkerDefinition+ {elementType=Block}

//private StatementRecover ::= !(int | string | '}' | '=')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )

// Todo - Need getIdentifier?
FunctionDefinition ::= FunctionWithReceiver | FunctionWithoutReceiver {
    pin=1 methods=[/*getIdentifier*/ getName] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaFunctionDefinitionStub"
}
private FunctionWithReceiver ::= (public)? (native)? function (LT Parameter GT)? CallableUnitSignature (CallableUnitBody | SEMICOLON) {pin=3}
private FunctionWithoutReceiver ::= (public)? (native)? function identifier DOUBLE_COLON CallableUnitSignature CallableUnitBody {pin=3}

LambdaFunction ::= function LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS ReturnParameter? CallableUnitBody {pin=1}

// Todo - cache and add Signature owner?
CallableUnitSignature ::= identifier LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS ReturnParameter? {pin=1}

StructDefinition ::= (public)? struct identifier StructBody {
    pin=2
    methods=[getName]
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaStructDefinitionStub"
}

StructBody ::= LEFT_BRACE FieldDefinition* PrivateStructBody? RIGHT_BRACE

// Todo - Cache
PrivateStructBody ::= private COLON FieldDefinition* {pin=1}

TypeDefinition ::= (public)? type identifier TypeName {pin=2}

ObjectBody ::= PublicObjectFields? PrivateObjectFields? ObjectInitializer? ObjectFunctions?

PublicObjectFields ::= public LEFT_BRACE ObjectFieldDefinition* RIGHT_BRACE {pin=1}

PrivateObjectFields ::= private LEFT_BRACE ObjectFieldDefinition* RIGHT_BRACE {pin=1}

ObjectInitializer ::= AnnotationAttachment* documentationAttachment? (public)? (native)? new ObjectInitializerParameterList CallableUnitBody {pin=5}

ObjectInitializerParameterList ::= LEFT_PARENTHESIS ObjectParameterList? RIGHT_PARENTHESIS

ObjectFunctions ::= (AnnotationAttachment* documentationAttachment? deprecatedAttachment? ObjectFunctionDefinition)+

// TODO merge with fieldDefinition later
ObjectFieldDefinition ::= TypeName identifier (COLON SimpleLiteral)? (COMMA | SEMICOLON)

// TODO try to merge with formalParameterList later
ObjectParameterList ::= (ObjectDefaultableParameter | ObjectParameter) (COMMA (ObjectDefaultableParameter | ObjectParameter))* (COMMA RestParameter)? | RestParameter

// Todo - Revert back the changes?
// TODO try to merge with parameter later
ObjectParameter ::= AnnotationAttachment* (identifier | TypeName identifier)

// TODO try to merge with defaultable Parameter later
ObjectDefaultableParameter ::= ObjectParameter COLON Expression

// TODO merge with functionDefinition later
ObjectFunctionDefinition ::= (public)? (native)? function ObjectCallableUnitSignature (CallableUnitBody | SEMICOLON)

//TODO merge with callableUnitSignature later
ObjectCallableUnitSignature ::= identifier LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS ReturnParameter?



AnnotationDefinition ::= (public)? annotation (LT AttachmentPoint (COMMA AttachmentPoint)* GT)? identifier UserDefineTypeName? SEMICOLON {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaAnnotationDefinitionStub"
}

//private AttachmentPointsRecover ::= !(GT | Identifier | SEMICOLON)

EnumDefinition ::= (public)? enum identifier LEFT_BRACE Enumerator (COMMA Enumerator)* RIGHT_BRACE {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaEnumDefinitionStub"
}

Enumerator ::= identifier {
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaEnumeratorStub"
}

GlobalVariableDefinition ::= (public)? TypeName identifier ((ASSIGN | SAFE_ASSIGNMENT) Expression)? SEMICOLON {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaGlobalVariableDefinitionStub"
}

TransformerDefinition ::= (public)? transformer LT ParameterList GT (identifier LEFT_PARENTHESIS ParameterList? RIGHT_PARENTHESIS)? CallableUnitBody {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaTransformerDefinitionStub"
}

// Todo - Need to update the service?
// Note - "parameter" is treated differently here because there is a parser rule named "parameter" as well.
AttachmentPoint ::= service | resource | function | struct | enum | endpoint | const | TYPE_PARAMETER | annotation | transformer {
    /*recoverWhile=AttachmentPointRecover*/
}

//private AttachmentPointRecover ::= !(COMMA | GT)

ConstantDefinition ::= (public)? const ValueTypeName identifier (ASSIGN | SAFE_ASSIGNMENT) Expression SEMICOLON {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaConstantDefinitionStub"
}

// Todo - Rename as declaration
WorkerDefinition ::= worker identifier LEFT_BRACE Block RIGHT_BRACE {
    pin=1
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaWorkerDefinitionStub"
}

GlobalEndpointDefinition ::= public? EndpointDefinition {
    pin=2
    methods=[getIdentifier] stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaGlobalEndpointDefinitionStub"
}

EndpointDefinition ::= AnnotationAttachment* endpoint EndpointType identifier EndpointInitlization? SEMICOLON {
    pin=2
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaEndpointDefinitionStub"
}

EndpointType ::= NameReference

EndpointInitlization ::= RecordLiteral | ASSIGN VariableReference

//todo
TypeName ::= TupleTypeName
             | GroupTypeName
             | ArrayTypeName
             | UnionTypeName
             | ObjectTypeName
             | SimpleTypeName
//             | AnnotatedTypeName
             | NullableTypeName

SimpleTypeName ::= NULL_LITERAL
                   | AnyTypeName
                   | TypeDescTypeName
                   | ValueTypeName
                   | ReferenceTypeName
AnyTypeName ::= any
TypeDescTypeName ::= typedesc

//AnnotatedTypeName ::= AnnotationAttachment+ SimpleTypeName
ArrayTypeName ::= TypeName (LEFT_BRACKET RIGHT_BRACKET)+
NullableTypeName ::= TypeName PIPE NULL_LITERAL
UnionTypeName ::= TypeName (PIPE TypeName)+
GroupTypeName ::= LEFT_PARENTHESIS TypeName RIGHT_PARENTHESIS
TupleTypeName ::= LEFT_PARENTHESIS TypeName (COMMA TypeName)* RIGHT_PARENTHESIS
ObjectTypeName ::= object LEFT_BRACE ObjectBody RIGHT_BRACE

BuiltInTypeName ::= AnyTypeName
                    | SimpleTypeName (LEFT_BRACKET RIGHT_BRACKET)+
                    | TypeDescTypeName
                    | ValueTypeName
                    | BuiltInReferenceTypeName

ReferenceTypeName ::= BuiltInReferenceTypeName
                      | UserDefineTypeName
                      | AnonStructTypeName

UserDefineTypeName ::= NameReference

AnonStructTypeName ::= struct StructBody {pin=1}

ValueTypeName ::=   boolean | int | float | string | blob

BuiltInReferenceTypeName ::= MapTypeName
                             | FutureTypeName
                             | XmlTypeName
                             | JsonTypeName
                             | TableTypeName
                             | StreamTypeName
                             | FunctionTypeName
MapTypeName ::= map (LT TypeName GT)? {pin=1}
FutureTypeName ::= future (LT TypeName GT)? {pin=1}
XmlTypeName ::= xml (LT (LEFT_BRACE XmlNamespaceName RIGHT_BRACE)? XmlLocalName GT)? {pin=1}
JsonTypeName ::= json (LT NameReference GT)? {pin=1}
TableTypeName ::= table (LT NameReference GT)? {pin=1}
StreamTypeName ::= stream (LT NameReference GT)? {pin=1}

// Todo - Pin 1?
FunctionTypeName ::= function LEFT_PARENTHESIS (ParameterList | ParameterTypeNameList)? RIGHT_PARENTHESIS ReturnParameter? {pin=3}

XmlNamespaceName ::= QUOTED_STRING_LITERAL

XmlLocalName ::= identifier

// Todo - Cache
AnnotationAttachment ::= AT NameReference RecordLiteral?


// STATEMENTS / BLOCKS =================================================================================================

// Todo - Add recovery rules
// Note - Expression statement should be the first one.
Statement ::=
        WhileStatement
    |   NextStatement
    |   ForeachStatement
    |   matchStatement
    |   BreakStatement
    |   ThrowStatement
    |   ReturnStatement
    |   AbortStatement
    |   failStatement
    |   LockStatement
    |   NamespaceDeclarationStatement
    |   TransactionStatement
    |   IfElseStatement
    |   TryCatchStatement
    |   ForkJoinStatement
    |   ExpressionStmt
    |   WorkerInteractionStatement
    |   AssignmentStatement
    |   tupleDestructuringStatement
    |   CompoundAssignmentStatement
    |   PostIncrementStatement
    |   VariableDefinitionStatement
    // Todo - Add streaming
//    |   wheneverStatement
//    |   streamingQueryStatement
//    |   StreamingQueryStatement
{recoverWhile = StatementRecover}

// Todo - Add more tokens
private StatementRecover ::= !(int|string|float|boolean|blob|any|json|xml|xmlns|map|table|function|'}'|';'|typedesc|future|await|var|while|match|foreach|next|break|fork|try|throw|return|abort|fail|lock|transaction|if|identifier)

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | next |try |*/ int )

VariableDefinitionStatement ::= TypeName identifier ((ASSIGN | SAFE_ASSIGNMENT) (ActionInvocation | Expression))? SEMICOLON {
// Note - Resource definition cannot be identified correctly with this pin.
    pin(".*")=1
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaVariableDefinitionStatementStub"
}

RecordLiteral ::= LEFT_BRACE (RecordKeyValue (COMMA RecordKeyValue)*)? RIGHT_BRACE {pin(".*")=1}

RecordKeyValue ::= RecordKey COLON Expression {pin=1}

RecordKey ::= identifier | SimpleLiteral

ArrayLiteral ::= LEFT_BRACKET ExpressionList? RIGHT_BRACKET

TypeInitExpr ::= new UserDefineTypeName LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS | new (LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS)? {pin=1}

AssignmentStatement ::= (var)? VariableReference (ASSIGN | SAFE_ASSIGNMENT) (ActionInvocation | Expression) SEMICOLON /*{pin=2}*/

tupleDestructuringStatement ::= var? LEFT_PARENTHESIS VariableReferenceList RIGHT_PARENTHESIS ASSIGN (ActionInvocation | Expression) SEMICOLON
                                | LEFT_PARENTHESIS ParameterList RIGHT_PARENTHESIS ASSIGN (ActionInvocation | Expression) SEMICOLON

CompoundAssignmentStatement ::= VariableReference CompoundOperator Expression SEMICOLON

CompoundOperator ::= COMPOUND_ADD | COMPOUND_SUB | COMPOUND_MUL | COMPOUND_DIV

PostIncrementStatement ::= VariableReference PostArithmeticOperator SEMICOLON

PostArithmeticOperator ::= INCREMENT | DECREMENT

VariableReferenceList ::= VariableReference (COMMA VariableReference)*

IfElseStatement ::= IfClause ElseIfClause* ElseClause? /*{pin=1}*/

IfClause ::= if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

ElseIfClause ::= else if LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=2}

ElseClause ::= else LEFT_BRACE Block RIGHT_BRACE {pin=1}

matchStatement ::= match Expression LEFT_BRACE matchPatternClause+ RIGHT_BRACE {pin=1}

matchPatternClause ::= namedPattern | unnamedPattern
private unnamedPattern ::= TypeName EQUAL_GT ((LEFT_BRACE Statement+ RIGHT_BRACE) | Statement) {pin=2}
private namedPattern ::= TypeName identifier EQUAL_GT ((LEFT_BRACE Statement+ RIGHT_BRACE)|Statement) {pin=3}

ForeachStatement ::= foreach LEFT_PARENTHESIS? VariableReferenceList in (Expression | IntRangeExpression) RIGHT_PARENTHESIS? LEFT_BRACE Block RIGHT_BRACE {pin=1}

IntRangeExpression ::= Expression RANGE Expression | (LEFT_BRACKET|LEFT_PARENTHESIS) Expression RANGE Expression (RIGHT_BRACKET|RIGHT_PARENTHESIS)

// Todo - pin 1?
WhileStatement ::= while LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE

NextStatement ::= next SEMICOLON {pin=1}

BreakStatement ::= break SEMICOLON {pin=1}

// typeName is only message
ForkJoinStatement ::= fork LEFT_BRACE WorkerDefinition* RIGHT_BRACE JoinClause? TimeoutClause? {pin=1}

// below typeName is only 'message[]'
JoinClause ::= join (LEFT_PARENTHESIS JoinConditions RIGHT_PARENTHESIS)? LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

// Todo - Needs reorder?
JoinConditions ::= (some IntegerLiteral | all) (identifier (COMMA identifier)*)? {pin=1}

// below typeName is only 'message[]'
TimeoutClause ::= timeout LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

TryCatchStatement ::= try LEFT_BRACE Block RIGHT_BRACE CatchClauses {pin=1}

CatchClauses ::= CatchClause+ FinallyClause? | FinallyClause

CatchClause ::= catch LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

FinallyClause ::= finally LEFT_BRACE Block RIGHT_BRACE {pin=1}

ThrowStatement ::= throw Expression SEMICOLON {pin=1}

ReturnStatement ::= return ExpressionList? SEMICOLON {pin=1}

WorkerInteractionStatement ::= TriggerWorker | WorkerReply

// below left identifier is of type TYPE_MESSAGE and the right identifier is of type WORKER
TriggerWorker ::=  ExpressionList RARROW (fork | identifier) SEMICOLON {pin=2}

// below left identifier is of type WORKER and the right identifier is of type message
WorkerReply ::= ExpressionList LARROW identifier SEMICOLON {pin=2}

// Note - Order of 'simpleVariableReference' and 'functionInvocationReference' because otherwise all function
// invocations will match simpleVariableReference first.
VariableReference ::= MapArrayVariableReference
                      | InvocationReference
                      | FieldVariableReference
                      | XmlAttribVariableReference
                      | FunctionInvocationReference
                      | SimpleVariableReference
                      | AwaitExpressionReference

InvocationReference ::= VariableReference Invocation
MapArrayVariableReference ::= VariableReference Index
FieldVariableReference ::= VariableReference Field
XmlAttribVariableReference ::= VariableReference XmlAttrib
FunctionInvocationReference ::= (async)? FunctionInvocation
SimpleVariableReference ::=  NameReference
AwaitExpressionReference ::= AwaitExpression

Field ::= DOT identifier {
    /*pin=1*/
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaFieldStub"
}

Index ::= LEFT_BRACKET Expression RIGHT_BRACKET /*{pin=1}*/

XmlAttrib ::= AT (LEFT_BRACKET Expression RIGHT_BRACKET)? /*{pin=1}*/

// Todo - Need to pin?
FunctionInvocation ::= NameReference LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS

// Todo - Adding pin will mess function invocation.
Invocation ::= DOT AnyIdentifierName LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS /*{pin=1}*/

InvocationArgList ::= InvocationArg (COMMA InvocationArg)* {pin(".*")=1}

InvocationArg ::= NamedArgs | RestArgs | Expression

// Todo - Update the recovery rule
ActionInvocation ::= async? NameReference RARROW FunctionInvocation {pin=3 /*recoverWhile=StatementRecover*/}

ExpressionList ::= Expression (COMMA Expression)* {
    pin(".*")=1
//    recoverWhile = ExpressionListRecover
}
//private ExpressionListRecover ::= !(RIGHT_PARENTHESIS | SEMICOLON)

ExpressionStmt ::= (ActionInvocation | VariableReference) SEMICOLON /*{pin=1}*/

TransactionStatement ::= TransactionClause OnretryClause?

TransactionClause ::= transaction (WITH TransactionPropertyInitStatementList)? LEFT_BRACE Block RIGHT_BRACE {pin=1}

TransactionPropertyInitStatement ::= RetriesStatement | OncommitStatement | OnabortStatement

TransactionPropertyInitStatementList ::= TransactionPropertyInitStatement (COMMA TransactionPropertyInitStatement)*

LockStatement ::= lock LEFT_BRACE Block RIGHT_BRACE {pin=1}

OnretryClause ::= onretry LEFT_BRACE Block RIGHT_BRACE {pin=1}

AbortStatement ::= abort SEMICOLON {pin=1}

failStatement ::= fail SEMICOLON {pin=1}

RetriesStatement ::= retries ASSIGN Expression {pin=1}

OncommitStatement ::= oncommit ASSIGN Expression

OnabortStatement ::= onabort ASSIGN Expression

NamespaceDeclarationStatement ::= NamespaceDeclaration /*{pin=1}*/

NamespaceDeclaration ::= xmlns QUOTED_STRING_LITERAL (as identifier)? SEMICOLON {
    pin=1
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaNamespaceDeclarationStub"
}

Expression
    ::=
        SimpleLiteralExpression
    |   StringTemplateLiteralExpression
    |   XmlLiteralExpression
    |   RecordLiteralExpression
    |   BracedOrTupleExpression
    |   TernaryExpression {/*pin=1 */ /*recoverWhile=ExpressionRecover*/}
    |   ArrayLiteralExpression
    |   ValueTypeTypeExpression
    |   BuiltInReferenceTypeTypeExpression
    |   VariableReferenceExpression
    |   LambdaFunctionExpression
    |   TypeInitExpression
    |   TypeConversionExpression
    |   UnaryExpression // Unary > Type access - if (typeof temp_int)
    |   TypeAccessExpression
    |   BinaryPowExpression
    |   BinaryDivMulModExpression
    |   BinaryAddSubExpression
    |   BinaryCompareExpression
    |   BinaryEqualExpression
    |   BinaryAndExpression
    |   BinaryOrExpression
    |   AwaitExpression {
    recoverWhile=ExpressionRecover
}

private ExpressionRecover ::= !(int|string|float|boolean|blob|any|map|table|function|'}'|';'|var |while|match|foreach|next|break|fork|try|throw|return|abort|fail|lock|xmlns|transaction|if)

fake BinaryExpression ::= Expression {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

//private ExpressionRecover ::=  !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var )
SimpleLiteralExpression ::= SimpleLiteral
ArrayLiteralExpression ::= ArrayLiteral
RecordLiteralExpression ::= RecordLiteral
XmlLiteralExpression ::= XmlLiteral
StringTemplateLiteralExpression ::= StringTemplateLiteral
ValueTypeTypeExpression ::= ValueTypeName DOT identifier
BuiltInReferenceTypeTypeExpression ::= BuiltInReferenceTypeName DOT identifier
VariableReferenceExpression ::= VariableReference
LambdaFunctionExpression ::= LambdaFunction
TypeInitExpression ::= TypeInitExpr
TypeConversionExpression ::= LT TypeName (COMMA FunctionInvocation)? GT Expression {pin=1}
TypeAccessExpression ::= typeof (BuiltInTypeName | Expression){pin=1}
UnaryExpression ::= (ADD | SUB | NOT | lengthof | untaint) Expression {pin=1}
BracedOrTupleExpression ::= LEFT_PARENTHESIS Expression (COMMA Expression)* RIGHT_PARENTHESIS
BinaryPowExpression ::= Expression POW Expression
BinaryDivMulModExpression ::= Expression (DIV | MUL | MOD) Expression
BinaryAddSubExpression ::= Expression (ADD | SUB) Expression
BinaryCompareExpression ::= Expression (LT_EQUAL | GT_EQUAL | GT | LT) Expression
BinaryEqualExpression ::= Expression (EQUAL | NOT_EQUAL) Expression
BinaryAndExpression ::= Expression AND Expression
BinaryOrExpression ::= Expression OR Expression
TernaryExpression ::= Expression QUESTION_MARK Expression COLON Expression {pin=2}
AwaitExpression ::= await Expression
//reusable productions

NameReference ::= <<isPackageExpected>> PackageReference identifier | identifier {
    methods=[/*getReference*/ getQualifier /*resolve*/ resolveType isReferenceToLocalPackage]
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaNameReferenceStub"
//    extends=test
//    elementType=test
}

PackageReference ::= identifier COLON {
    pin=2
    methods=[getReference]
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaPackageReferenceStub"
}

ReturnParameter ::= returns AnnotationAttachment* TypeName {pin=1}

ParameterTypeNameList ::= parameterTypeName (COMMA parameterTypeName)* {pin=1 /*recoverWhile=RecoverParameter*/}

parameterTypeName ::= AnnotationAttachment* TypeName

ParameterList ::= Parameter (COMMA Parameter)* {pin(".*")=1 /*recoverWhile=RecoverParameter*/}

//private RecoverParameter ::= !(string | COMMA | RIGHT_PARENTHESIS | identifier)

// Todo - Add indexing
Parameter ::= SimpleParameter | TupleParameter
private SimpleParameter ::= AnnotationAttachment* TypeName identifier /*{pin=2}*/
private TupleParameter ::= AnnotationAttachment* LEFT_PARENTHESIS TypeName identifier (COMMA TypeName identifier)* RIGHT_PARENTHESIS

DefaultableParameter ::= Parameter ASSIGN Expression

RestParameter ::= AnnotationAttachment* TypeName ELLIPSIS identifier

FormalParameterList ::= (DefaultableParameter | Parameter) (COMMA (DefaultableParameter | Parameter))* (COMMA RestParameter)? | RestParameter

// Todo - cache
FieldDefinition ::= TypeName identifier (ASSIGN Expression)? SEMICOLON {
    pin=1
    stubClass="org.ballerinalang.plugins.idea.stubs.BallerinaFieldDefinitionStub"
}

SimpleLiteral ::= (ADD|SUB)? IntegerLiteral
                  | (ADD|SUB)? FLOATING_POINT_LITERAL
                  | QUOTED_STRING_LITERAL
                  | BOOLEAN_LITERAL
                  | NULL_LITERAL

// ยง3.10.1 Integer Literals
IntegerLiteral ::= DECIMAL_INTEGER_LITERAL | HEX_INTEGER_LITERAL | OCTAL_INTEGER_LITERAL | BINARY_INTEGER_LITERAL

NamedArgs ::= identifier ASSIGN Expression {pin=2}

RestArgs ::= ELLIPSIS Expression {pin=1}

// XML parsing

XmlLiteral ::= XML_LITERAL_START XmlItem XML_LITERAL_END {pin=1}

XmlItem ::= Element | ProcIns | Comment | XmlText | cdata

Content ::= XmlText? ((Element | cdata | ProcIns | Comment) XmlText?)*

Comment ::= XML_COMMENT_START (XML_COMMENT_TEMPLATE_TEXT Expression EXPRESSION_END)* XML_COMMENT_TEXT

Element ::= StartTag Content CloseTag | EmptyTag

StartTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_CLOSE {pin=1}

CloseTag ::= XML_TAG_OPEN_SLASH XmlQualifiedName XML_TAG_CLOSE {pin=1}

EmptyTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_SLASH_CLOSE {pin=1}

ProcIns ::= XML_TAG_SPECIAL_OPEN (XML_PI_TEMPLATE_TEXT Expression EXPRESSION_END)* XML_PI_TEXT

Attribute ::= XmlQualifiedName EQUALS XmlQuotedString;

XmlText ::= (XML_TEMPLATE_TEXT Expression EXPRESSION_END)+ XML_TEXT_SEQUENCE? | XML_TEXT_SEQUENCE

XmlQuotedString ::= XmlSingleQuotedString | XmlDoubleQuotedString

XmlSingleQuotedString ::= SINGLE_QUOTE (XML_SINGLE_QUOTED_TEMPLATE_STRING Expression EXPRESSION_END)* XML_SINGLE_QUOTED_STRING_SEQUENCE? SINGLE_QUOTE_END

XmlDoubleQuotedString ::= DOUBLE_QUOTE (XML_DOUBLE_QUOTED_TEMPLATE_STRING Expression EXPRESSION_END)* XML_DOUBLE_QUOTED_STRING_SEQUENCE? DOUBLE_QUOTE_END

XmlQualifiedName ::= (XML_QNAME QNAME_SEPARATOR)? XML_QNAME | XML_TAG_EXPRESSION_START Expression EXPRESSION_END

// Todo - Uncomment
StringTemplateLiteral ::= STRING_TEMPLATE_LITERAL_START StringTemplateContent? STRING_TEMPLATE_LITERAL_END {pin=1 /*recoverWhile=StringTemplateLiteralRecover*/}

// Todo - Update to statement recover
/*private StringTemplateLiteralRecover ::= !(SEMICOLON | string | int | identifier)*/

StringTemplateContent ::= StringTemplateExpressionContent | StringTemplateTextContent

private StringTemplateExpressionContent ::= StringTemplateExpression+ STRING_TEMPLATE_TEXT?
private StringTemplateExpression ::= STRING_TEMPLATE_EXPRESSION_START Expression EXPRESSION_END /*{pin=1}*/
private StringTemplateTextContent ::= STRING_TEMPLATE_TEXT

AnyIdentifierName ::= identifier | ReservedWord

ReservedWord ::= foreach | map


// Deprecated parsing.

deprecatedAttachment ::= DEPRECATED_TEMPLATE_START deprecatedText? DEPRECATED_TEMPLATE_END

deprecatedText ::= deprecatedTemplateInlineCode (DEPRECATED_TEMPLATE_TEXT | deprecatedTemplateInlineCode)*
                   | DEPRECATED_TEMPLATE_TEXT (DEPRECATED_TEMPLATE_TEXT | deprecatedTemplateInlineCode)*

deprecatedTemplateInlineCode ::= singleBackTickDeprecatedInlineCode | doubleBackTickDeprecatedInlineCode | tripleBackTickDeprecatedInlineCode

singleBackTickDeprecatedInlineCode ::= SB_DEPRECATED_INLINE_CODE_START SINGLE_BACK_TICK_INLINE_CODE? SINGLE_BACK_TICK_INLINE_CODE_END

doubleBackTickDeprecatedInlineCode ::= DB_DEPRECATED_INLINE_CODE_START DOUBLE_BACK_TICK_INLINE_CODE? DOUBLE_BACK_TICK_INLINE_CODE_END

tripleBackTickDeprecatedInlineCode ::= TB_DEPRECATED_INLINE_CODE_START TRIPLE_BACK_TICK_INLINE_CODE? TRIPLE_BACK_TICK_INLINE_CODE_END


// Documentation parsing.

documentationAttachment ::= DOCUMENTATION_TEMPLATE_START documentationTemplateContent? DOCUMENTATION_TEMPLATE_END

documentationTemplateContent ::= docText? documentationTemplateAttributeDescription+ | docText

documentationTemplateAttributeDescription ::= DOCUMENTATION_TEMPLATE_ATTRIBUTE_START identifier DOCUMENTATION_TEMPLATE_ATTRIBUTE_END docText?

docText ::= documentationTemplateInlineCode (DOCUMENTATION_TEMPLATE_TEXT | documentationTemplateInlineCode)*
            | DOCUMENTATION_TEMPLATE_TEXT  (DOCUMENTATION_TEMPLATE_TEXT | documentationTemplateInlineCode)*

documentationTemplateInlineCode ::= singleBackTickDocInlineCode | doubleBackTickDocInlineCode | tripleBackTickDocInlineCode

singleBackTickDocInlineCode ::= SB_DOC_INLINE_CODE_START SINGLE_BACK_TICK_INLINE_CODE? SINGLE_BACK_TICK_INLINE_CODE_END

doubleBackTickDocInlineCode ::= DB_DOC_INLINE_CODE_START DOUBLE_BACK_TICK_INLINE_CODE? DOUBLE_BACK_TICK_INLINE_CODE_END

tripleBackTickDocInlineCode ::= TB_DOC_INLINE_CODE_START TRIPLE_BACK_TICK_INLINE_CODE? TRIPLE_BACK_TICK_INLINE_CODE_END
