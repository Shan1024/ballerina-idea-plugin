{

  parserClass="com.simpleplugin.parser.SimpleParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Simple"
  psiImplClassSuffix="Impl"
  psiPackage="com.simpleplugin.psi"
  psiImplPackage="com.simpleplugin.psi.impl"

  elementTypeHolderClass="com.simpleplugin.psi.SimpleTypes"
  elementTypeClass="com.simpleplugin.psi.SimpleElementType"
  tokenTypeClass="com.simpleplugin.psi.SimpleTokenType"

//  psiImplUtilClass="com.simpleplugin.psi.impl.SimplePsiImplUtil"

  tokens=[

    Letter = 'regexp:[a-zA-Z_]'
    LetterOrDigit = 'regexp:[a-zA-Z0-9_]'
    WS = 'regexp:[ \t]+'
    NEW_LINE = 'regexp:[\r\n\u000C]+'
    LINE_COMMENT = 'regexp://~[\r\n]*'


    PACKAGE     = 'package'
    IMPORT      = 'import'
    AS          = 'as'
    PUBLIC      = 'public'
    PRIVATE      = 'private'
    NATIVE      = 'native'
    SERVICE     = 'service'
    RESOURCE    = 'resource'
    FUNCTION    = 'function'
    CONNECTOR   = 'connector'
    ACTION      = 'action'
    STRUCT      = 'struct'
    ANNOTATION  = 'annotation'
    ENUM        = 'enum'
//    PARAMETER   = 'parameter'
    CONST       = 'const'
    TRANSFORMER = 'transformer'
    WORKER      = 'worker'
    ENDPOINT    = 'endpoint'
    XMLNS       = 'xmlns'
    RETURNS     = 'returns'
//    VERSION     = 'version'

    TYPE_INT        = 'int'
    TYPE_FLOAT      = 'float'
    TYPE_BOOL       = 'boolean'
    TYPE_STRING     = 'string'
    TYPE_BLOB       = 'blob'
    TYPE_MAP        = 'map'
    TYPE_JSON       = 'json'
    TYPE_XML        = 'xml'
    TYPE_TABLE      = 'table'
    TYPE_ANY        = 'any'
    TYPE_TYPE       = 'type'

    VAR         = 'var'
    CREATE      = 'create'
    ATTACH      = 'attach'
    IF          = 'if'
    ELSE        = 'else'
    FOREACH     = 'foreach'
    WHILE       = 'while'
    NEXT        = 'next'
    BREAK       = 'break'
    FORK        = 'fork'
    JOIN        = 'join'
    SOME        = 'some'
    ALL         = 'all'
    TIMEOUT     = 'timeout'
    TRY         = 'try'
    CATCH       = 'catch'
    FINALLY     = 'finally'
    THROW       = 'throw'
    RETURN      = 'return'
    TRANSACTION = 'transaction'
    ABORT       = 'abort'
    FAILED      = 'failed'
    RETRIES     = 'retries'
    LENGTHOF    = 'lengthof'
    TYPEOF      = 'typeof'
    WITH        = 'with'
    BIND        = 'bind'
    IN          = 'in'
    LOCK        = 'lock'

    // Separators

    SEMICOLON           = ';'
    COLON               = '='
    DOT                 = '.'
    COMMA               = ','
    LEFT_BRACE          = '{'
    RIGHT_BRACE         = '}'
    LEFT_PARENTHESIS    = '('
    RIGHT_PARENTHESIS   = ')'
    LEFT_BRACKET        = '['
    RIGHT_BRACKET       = ']'
    QUESTION_MARK       = '?'

    // Arithmetic operators

    ASSIGN  = '='
    ADD     = '+'
    SUB     = '-'
    MUL     = '*'
    DIV     = '/'
    POW     = '^'
    MOD     = '%'

    // Relational operators

    NOT         = '!'
    EQUAL       = '=='
    NOT_EQUAL   = '!='
    GT          = '>'
    LT          = '<'
    GT_EQUAL    = '>='
    LT_EQUAL    = '<='
    AND         = '&&'
    OR          = '||'

    // Additional symbols

    RARROW      = '->'
    LARROW      = '<-'
    AT          = '@'
    BACKTICK    = '`'
    RANGE       = '..'


  
  ]


}

compilationUnit ::= packageDeclaration? (importDeclaration /*| namespaceDeclaration*/)* (/*annotationAttachment**/ definition)*

packageDeclaration ::= PACKAGE packageName SEMICOLON {pin(".*")=1}

packageName ::= Identifier (DOT Identifier)* version? {pin(".*")=1}

version ::= (VERSION Identifier){pin(".*")=1};

importDeclaration ::= IMPORT packageName (AS Identifier)? SEMICOLON {pin(".*")=1}

definition ::= serviceDefinition | functionDefinition /*| connectorDefinition | structDefinition | enumDefinition |
 constantDefinition | annotationDefinition | globalVariableDefinition | transformerDefinition*/
 {recoverWhile=TopLevelDefinitionRecover}

private TopLevelDefinitionRecover ::= !(FUNCTION | SERVICE)

serviceDefinition ::= SERVICE (LT Identifier GT) Identifier serviceBody {pin=1}
serviceBody ::=   LEFT_BRACE /*endpointDeclaration**/ variableDefinitionStatement* resourceDefinition* RIGHT_BRACE

resourceDefinition ::= /*annotationAttachment**/ RESOURCE Identifier LEFT_PARENTHESIS parameterList RIGHT_PARENTHESIS callableUnitBody {pin=1}


callableUnitBody ::= LEFT_BRACE /*endpointDeclaration**/ statement* RIGHT_BRACE
    /*| LEFT_BRACE endpointDeclaration* workerDeclaration+ RIGHT_BRACE*/

functionDefinition ::= nativeFunctionDefinition | nonNativeFunctionDefinition
nativeFunctionDefinition ::= (PUBLIC)? NATIVE FUNCTION (LT parameter GT)? callableUnitSignature SEMICOLON {pin=2}
nonNativeFunctionDefinition ::= (PUBLIC)? FUNCTION (LT parameter GT)? callableUnitSignature callableUnitBody {pin=2}


lambdaFunction ::= FUNCTION LEFT_PARENTHESIS parameterList? RIGHT_PARENTHESIS returnParameters? callableUnitBody

callableUnitSignature ::= Identifier LEFT_PARENTHESIS parameterList? RIGHT_PARENTHESIS returnParameters? {pin=1}

//connectorDefinition
//    :   (PUBLIC)? CONNECTOR Identifier LEFT_PARENTHESIS parameterList? RIGHT_PARENTHESIS connectorBody
//    ;
//
//connectorBody
//    :   LEFT_BRACE endpointDeclaration* variableDefinitionStatement* actionDefinition* RIGHT_BRACE
//    ;
//
//actionDefinition
//    :   annotationAttachment* NATIVE ACTION  callableUnitSignature SEMICOLON
//    |   annotationAttachment* ACTION callableUnitSignature callableUnitBody
//    ;
//
//structDefinition
//    :   (PUBLIC)? STRUCT Identifier structBody
//    ;
//
//structBody
//    :   LEFT_BRACE fieldDefinition* privateStructBody? RIGHT_BRACE
//    ;
//
//
//privateStructBody
//    :   PRIVATE COLON fieldDefinition*
//    ;
//
//annotationDefinition
//    : (PUBLIC)? ANNOTATION Identifier (ATTACH attachmentPoint (COMMA attachmentPoint)*)? annotationBody
//
//    ;
//
//enumDefinition
//    : (PUBLIC)? ENUM Identifier LEFT_BRACE enumerator (COMMA enumerator)* RIGHT_BRACE
//    ;
//
//enumerator
//    : Identifier
//    ;
//
//globalVariableDefinition
//    :   (PUBLIC)? typeName Identifier (ASSIGN expression )? SEMICOLON
//    ;
//
//transformerDefinition
//    :   (PUBLIC)? TRANSFORMER LT parameterList GT (Identifier LEFT_PARENTHESIS parameterList? RIGHT_PARENTHESIS)? callableUnitBody
//    ;
//
//attachmentPoint
//     : SERVICE (LT Identifier? GT)?         # serviceAttachPoint
//     | RESOURCE                             # resourceAttachPoint
//     | CONNECTOR                            # connectorAttachPoint
//     | ACTION                               # actionAttachPoint
//     | FUNCTION                             # functionAttachPoint
//     | STRUCT                               # structAttachPoint
//     | ENUM                                 # enumAttachPoint
//     | CONST                                # constAttachPoint
//     | PARAMETER                            # parameterAttachPoint
//     | ANNOTATION                           # annotationAttachPoint
//     | TRANSFORMER                          # transformerAttachPoint
//     ;
//
//annotationBody
//    :  LEFT_BRACE fieldDefinition* RIGHT_BRACE
//    ;
//
//constantDefinition
//    :   (PUBLIC)? CONST valueTypeName Identifier ASSIGN expression SEMICOLON
//    ;
//
//workerDeclaration
//    :   workerDefinition LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//workerDefinition
//    :   WORKER Identifier
//    ;

typeName ::= TYPE_ANY |TYPE_TYPE | valueTypeName | referenceTypeName /*| typeName*/ (LEFT_BRACKET RIGHT_BRACKET)+

builtInTypeName ::= TYPE_ANY | TYPE_TYPE | valueTypeName | builtInReferenceTypeName | typeName (LEFT_BRACKET RIGHT_BRACKET)+

referenceTypeName ::= builtInReferenceTypeName | userDefineTypeName | anonStructTypeName

userDefineTypeName ::= nameReference

anonStructTypeName ::= STRUCT structBody


valueTypeName ::=   TYPE_BOOL | TYPE_INT | TYPE_FLOAT | TYPE_STRING |TYPE_BLOB

builtInReferenceTypeName
    ::=   TYPE_MAP (LT typeName GT)?
    |   TYPE_XML (LT (LEFT_BRACE xmlNamespaceName RIGHT_BRACE)? xmlLocalName GT)?
    |   TYPE_JSON (LT nameReference GT)?
    |   TYPE_TABLE (LT nameReference GT)?
    |   functionTypeName

functionTypeName ::= FUNCTION LEFT_PARENTHESIS (parameterList | typeList)? RIGHT_PARENTHESIS returnParameters?

//xmlNamespaceName
//    :   QuotedStringLiteral
//    ;
//
//xmlLocalName
//    :   Identifier
//    ;
//
// annotationAttachment
//     :   AT nameReference LEFT_BRACE annotationAttributeList? RIGHT_BRACE
//     ;
//
// annotationAttributeList
//     :   annotationAttribute (COMMA annotationAttribute)*
//     ;
//
// annotationAttribute
//     :    Identifier COLON annotationAttributeValue
//     ;
//
// annotationAttributeValue
//     :   simpleLiteral
//     |   nameReference
//     |   annotationAttachment
//     |   annotationAttributeArray
//     ;
//
// annotationAttributeArray
//     :   LEFT_BRACKET (annotationAttributeValue (COMMA annotationAttributeValue)*)? RIGHT_BRACKET
//     ;
//
// //============================================================================================================
//// STATEMENTS / BLOCKS

statement
    ::=   variableDefinitionStatement
    |   assignmentStatement
    /*|   bindStatement
    |   ifElseStatement
    |   foreachStatement
    |   whileStatement
    |   nextStatement
    |   breakStatement
    |   forkJoinStatement
    |   tryCatchStatement
    |   throwStatement
    |   returnStatement
    |   workerInteractionStatement
    |   expressionStmt
    |   transactionStatement
    |   abortStatement
    |   lockStatement
    |   namespaceDeclarationStatement*/



variableDefinitionStatement ::= typeName Identifier (ASSIGN expression)? SEMICOLON


//recordLiteral
//    :   LEFT_BRACE (recordKeyValue (COMMA recordKeyValue)*)? RIGHT_BRACE
//    ;
//
//recordKeyValue
//    :   recordKey COLON expression
//    ;
//
//recordKey
//    :   Identifier
//    |   simpleLiteral
//    ;
//
//arrayLiteral
//    :   LEFT_BRACKET expressionList? RIGHT_BRACKET
//    ;
//
//connectorInit
//    :   CREATE userDefineTypeName LEFT_PARENTHESIS expressionList? RIGHT_PARENTHESIS
//    ;
//
//endpointDeclaration
//    :   endpointDefinition LEFT_BRACE ((variableReference | connectorInit) SEMICOLON)? RIGHT_BRACE
//    ;
//
//endpointDefinition
//    :   ENDPOINT (LT nameReference GT) Identifier
//    ;

assignmentStatement ::= (VAR)? variableReferenceList ASSIGN expression SEMICOLON

//bindStatement
//    :   BIND expression WITH Identifier SEMICOLON
//    ;

variableReferenceList ::= variableReference (COMMA variableReference)*


//ifElseStatement
//    :  ifClause elseIfClause* elseClause?
//    ;
//
//ifClause
//    :   IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//elseIfClause
//    :   ELSE IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//elseClause
//    :   ELSE LEFT_BRACE statement*RIGHT_BRACE
//    ;
//
//foreachStatement
//    :   FOREACH LEFT_PARENTHESIS? variableReferenceList IN  (expression | intRangeExpression) RIGHT_PARENTHESIS? LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//intRangeExpression
//    : expression RANGE expression
//    | (LEFT_BRACKET|LEFT_PARENTHESIS) expression RANGE expression (RIGHT_BRACKET|RIGHT_PARENTHESIS)
//    ;
//
//whileStatement
//    :   WHILE LEFT_PARENTHESIS expression RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//nextStatement
//    :   NEXT SEMICOLON
//    ;
//
//breakStatement
//    :   BREAK SEMICOLON
//    ;
//
//// typeName is only message
//forkJoinStatement
//    : FORK LEFT_BRACE workerDeclaration* RIGHT_BRACE joinClause? timeoutClause?
//    ;
//
//// below typeName is only 'message[]'
//joinClause
//    :   JOIN (LEFT_PARENTHESIS joinConditions RIGHT_PARENTHESIS)? LEFT_PARENTHESIS typeName Identifier RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//joinConditions
//    : SOME IntegerLiteral (Identifier (COMMA Identifier)*)?     # anyJoinCondition
//    | ALL (Identifier (COMMA Identifier)*)?                     # allJoinCondition
//    ;
//
//// below typeName is only 'message[]'
//timeoutClause
//    :   TIMEOUT LEFT_PARENTHESIS expression RIGHT_PARENTHESIS LEFT_PARENTHESIS typeName Identifier RIGHT_PARENTHESIS  LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//tryCatchStatement
//    :   TRY LEFT_BRACE statement* RIGHT_BRACE catchClauses
//    ;
//
//catchClauses
//    : catchClause+ finallyClause?
//    | finallyClause
//    ;
//
//catchClause
//    :  CATCH LEFT_PARENTHESIS typeName Identifier RIGHT_PARENTHESIS LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//finallyClause
//    : FINALLY LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//throwStatement
//    :   THROW expression SEMICOLON
//    ;
//
//returnStatement
//    :   RETURN expressionList? SEMICOLON
//    ;
//
//workerInteractionStatement
//    :   triggerWorker
//    |   workerReply
//    ;
//
//// below left Identifier is of type TYPE_MESSAGE and the right Identifier is of type WORKER
//triggerWorker
//    :   expressionList RARROW Identifier SEMICOLON #invokeWorker
//    |   expressionList RARROW FORK SEMICOLON     #invokeFork
//    ;
//
//// below left Identifier is of type WORKER and the right Identifier is of type message
//workerReply
//    :   expressionList LARROW Identifier SEMICOLON
//    ;

variableReference ::= functionInvocation | nameReference




//    |   variableReference index
//    |   variableReference field
//    |   variableReference xmlAttrib
//    |   variableReference invocation


//field
//    : DOT Identifier
//    ;
//
//index
//    : LEFT_BRACKET expression RIGHT_BRACKET
//    ;
//
//xmlAttrib
//    : AT (LEFT_BRACKET expression RIGHT_BRACKET)?
//    ;
//
functionInvocation ::= nameReference LEFT_PARENTHESIS expressionList? RIGHT_PARENTHESIS {pin=2}
//
//invocation
//    : DOT anyIdentifierName LEFT_PARENTHESIS expressionList? RIGHT_PARENTHESIS
//    ;

expressionList ::= expression (COMMA expression)*


expressionStmt
    ::=   variableReference SEMICOLON
    
//
//transactionStatement
//    :   transactionClause failedClause?
//    ;
//
//transactionClause
//    : TRANSACTION (WITH transactionPropertyInitStatementList)? LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//transactionPropertyInitStatement
//    : retriesStatement
//    ;
//
//transactionPropertyInitStatementList
//    : transactionPropertyInitStatement (COMMA transactionPropertyInitStatement)*
//    ;
//
//lockStatement
//    : LOCK LEFT_BRACE statement* RIGHT_BRACE
//    ;
//
//failedClause
//    :   FAILED LEFT_BRACE statement* RIGHT_BRACE
//    ;
//abortStatement
//    :   ABORT SEMICOLON
//    ;
//
//retriesStatement
//    :   RETRIES LEFT_PARENTHESIS expression RIGHT_PARENTHESIS
//    ;
//
//namespaceDeclarationStatement
//    :   namespaceDeclaration
//    ;
//
//namespaceDeclaration
//    :   XMLNS QuotedStringLiteral (AS Identifier)? SEMICOLON
//    ;
//
expression
    ::=  /* simpleLiteral
    |   arrayLiteral
    |   recordLiteral
    |   xmlLiteral
    |   stringTemplateLiteral
    |   valueTypeName DOT Identifier
    |   builtInReferenceTypeName DOT Identifier  */
//    |
       variableReference
//    |   lambdaFunction                                                      # lambdaFunctionExpression
//    |   connectorInit                                                       # connectorInitExpression
//    |   LEFT_PARENTHESIS typeName RIGHT_PARENTHESIS expression              # typeCastingExpression
//    |   LT typeName (COMMA functionInvocation)? GT expression               # typeConversionExpression
//    |   TYPEOF builtInTypeName                                              # typeAccessExpression
//    |   (ADD | SUB | NOT | LENGTHOF | TYPEOF) expression                    # unaryExpression
//    |   LEFT_PARENTHESIS expression RIGHT_PARENTHESIS                       # bracedExpression
//    |   expression POW expression                                           # binaryPowExpression
//    |   expression (DIV | MUL | MOD) expression                             # binaryDivMulModExpression
//    |   expression (ADD | SUB) expression                                   # binaryAddSubExpression
//    |   expression (LT_EQUAL | GT_EQUAL | GT | LT) expression               # binaryCompareExpression
//    |   expression (EQUAL | NOT_EQUAL) expression                           # binaryEqualExpression
//    |   expression AND expression                                           # binaryAndExpression
//    |   expression OR expression                                            # binaryOrExpression
//    |   expression QUESTION_MARK expression COLON expression                # ternaryExpression


////reusable productions

nameReference ::= (Identifier COLON)? Identifier

returnParameters ::= RETURNS? LEFT_PARENTHESIS (parameterList | typeList) RIGHT_PARENTHESIS {pin=3}

private typeList ::= typeName (COMMA typeName)* {pin=1}

parameterList ::= parameter (COMMA parameter)* {pin=1}

parameter ::= /*annotationAttachment**/ typeName Identifier

//fieldDefinition
//    :   typeName Identifier (ASSIGN simpleLiteral)? SEMICOLON
//    ;
//
//simpleLiteral
//    :   (SUB)? IntegerLiteral
//    |   (SUB)? FloatingPointLiteral
//    |   QuotedStringLiteral
//    |   BooleanLiteral
//    |   NullLiteral
//    ;
//
//// XML parsing
//
//xmlLiteral
//    :   XMLLiteralStart xmlItem XMLLiteralEnd
//    ;
//
//xmlItem
//    :   element
//    |   procIns
//    |   comment
//    |   text
//    |   CDATA
//    ;
//
//content
//    :   text? ((element | CDATA | procIns | comment) text?)*
//    ;
//
//comment
//    :   XML_COMMENT_START (XMLCommentTemplateText expression ExpressionEnd)* XMLCommentText
//    ;
//
//element
//    :   startTag content closeTag
//    |   emptyTag
//    ;
//
//startTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_CLOSE
//    ;
//
//closeTag
//    :   XML_TAG_OPEN_SLASH xmlQualifiedName XML_TAG_CLOSE
//    ;
//
//emptyTag
//    :   XML_TAG_OPEN xmlQualifiedName attribute* XML_TAG_SLASH_CLOSE
//    ;
//
//procIns
//    :   XML_TAG_SPECIAL_OPEN (XMLPITemplateText expression ExpressionEnd)* XMLPIText
//    ;
//
//attribute
//    :   xmlQualifiedName EQUALS xmlQuotedString;
//
//text
//    :   (XMLTemplateText expression ExpressionEnd)+ XMLText?
//    |   XMLText
//    ;
//
//xmlQuotedString
//    :   xmlSingleQuotedString
//    |   xmlDoubleQuotedString
//    ;
//
//xmlSingleQuotedString
//    :   SINGLE_QUOTE (XMLSingleQuotedTemplateString expression ExpressionEnd)* XMLSingleQuotedString? SINGLE_QUOTE_END
//    ;
//
//xmlDoubleQuotedString
//    :   DOUBLE_QUOTE (XMLDoubleQuotedTemplateString expression ExpressionEnd)* XMLDoubleQuotedString? DOUBLE_QUOTE_END
//    ;
//
//xmlQualifiedName
//    :   (XMLQName QNAME_SEPARATOR)? XMLQName
//    |   XMLTagExpressionStart expression ExpressionEnd
//    ;
//
//stringTemplateLiteral
//    :   StringTemplateLiteralStart stringTemplateContent? StringTemplateLiteralEnd
//    ;
//
//stringTemplateContent
//    :   (StringTemplateExpressionStart expression ExpressionEnd)+ StringTemplateText?
//    |   StringTemplateText
//    ;
//
//anyIdentifierName
//    : Identifier
//    | reservedWord
//    ;
//
//reservedWord
//    :   FOREACH
//    |   TYPE_MAP
//    ;
//

// lexer

Identifier ::=  (Letter+ LetterOrDigit*) /*| IdentifierLiteral*/

//private IdentifierLiteral ::= '|' IdentifierLiteralChar+ '|' ;
//
//private IdentifierLiteralChar ::= ![|\\\b\f\n\r\t] //| IdentifierLiteralEscapeSequence